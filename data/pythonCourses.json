{
  "exercises" : [{
      "index" : 0,
      "title" : "Freies Coden",
      "description" : "Dies ist keine Aufgabe. Hier kannst du so viel und frei coden, wie du willst.\nProbier hier doch einige neu gelernte Konzepte aus!\n\nHalte deinen Mauszeiger über den Titel der Aufgabe <b>(Freies Coden)</b>, um alle möglichen Kurse zu sehen.\n\nViel Spass!",
      "subexercises" : []
    }, {
      "index" : 1,
      "title" : "Grundlagen im Rechnen mit Variablen",
      "description" : "In diesem Kapitel befassen wir uns damit Variablen zu definieren und auszugeben. Variable wird in Python mit x = 3 definiert und mit print(x) ausgegeben. Dabei ist x die Variable, an dessen Stelle ein beliebiges Zeichen stehen könnte, die dem Wert 3 zugeordnet wird. Die Ausgabe print(x) gibt dabei den Wert der Variable x aus. Jeder Befehl, der dem Programm gegeben wird steht dabei in einer neuen Zeile. Im Code sieht dies folgendermassen aus.<code class=\"python\">x = 3\nprint(x)</code>",
      "subexercises" : [{
            "index" : 0,
            "description" : "Definiere eine Variable a mit dem Wert 7 und gib diese aus.",
            "startingCode" : "",
            "solution" : "a = 7\nprint(a)",
            "output" : "7"
          }, {
            "index" : 1,
            "description" : "Mit a = a + n wird eine Zahl n zu der Variable a addiert, wobei n also eine beliebige Zahl sein kann und a mit dem Wert a + n neu definiert wird. Definiere eine Varbable c mit dem Wert 3. Addiere danach 4 und gibt den Wert der Varbiable aus.",
            "startingCode" : "",
            "solution" : "a = 3\na = a + 4\nprint(a)",
            "output" : "7"
          }, {
            "index" : 2,
            "description" : "Die Addition einer Zahl zu einer Variable a kann auch abgekürzt mit a += n geschrieben werden. Dies hat dabei die gleiche Bedeutung wie a = a + n. Definiere nun eine Variable q mit dem Wert 5, addiere in einem ersten Schritt 18, gib das Zwischenresultat aus und addiere dazu in einem zweiten Schritt 1053 und gib q aus.",
            "startingCode" : "",
            "solution" : "q = 5\nq += 18\nprint(q)\nq += 1053\nprint(q)",
            "output" : "23\n1076"
          }, {
            "index" : 3,
            "description" : "Wie für die Addition einer Zahl zu einer Variable a kann auch eine Multiplikation einer Zahl mit einer Variable mit a *= n geschrieben werden. Definiere nun eine Variable b mit dem Wert 23 und multipliziere diese mit 14. Gib das Resultat aus.",
            "startingCode" : "",
            "solution" : "b = 23\nb *= 14\nprint(b)",
            "output" : "322"
          }, {
            "index" : 4,
            "description" : "Definiere eine Variable z mit dem Wert 5, addiere 7, multipliziere sie mit 9 und addiere 4. Gib jeweils die Zwischenresultate und das Endresultat aus.",
            "startingCode" : "",
            "solution" : "z = 5\nz += 7\nprint(z)\nz *= 9\nprint(z)\nz += 4\nprint(z)",
            "output" : "12\n108\n112"
          }, {
            "index" : 5,
            "description" : "Mit a ** b kann eine Variable a hoch eine Variable b gerechnet werden. Definiere eine Variable c mit dem Wert 25 und eine Variable e mit dem Wert 24. Addiere 5 zu c und rechne danach c hoch e und gib das Resultat aus.",
            "startingCode" : "",
            "solution" : "c = 25\ne = 24\nc += 5\nc = c ** e\nprint(c)",
            "output" : "282429536481000000000000000000000000"
          }, {
            "index" : 6,
            "description" : "Einer Variable kann nicht nur ein Wert zugeorndet werden, sondern auch ein Text. Dieses Datenformat wird dann als String bezeichnet. Der Text kann einer Variable wie folgt definiert und ausgegeben. <code class=\"python\">x = 'String'\nprint(x)</code>Definiere eine Variable text mit dem String von 'Dies ist ein kleiner Text' und gib diese aus.",
            "startingCode" : "",
            "solution" : "wert = 'Dies ist ein kleiner Text'\nprint(wert)",
            "output" : "Dies ist ein kleiner Text"
          }, {
            "index" : 7,
            "description" : "Definiere eine Variable wetter mit dem String 'Heute ist ein schoener Tag' und gib diese aus.",
            "startingCode" : "",
            "solution" : "wetter = 'Heute ist ein schoener Tag'\nprint(wetter)",
            "output" : "Heute ist ein schoener Tag"
            }, {
            "index" : 8,
            "description" : "Nun können wir auch zwei Datenformate gleichzeitig ausgeben. Dabei werden die Variablen in der Ausgabe durch Kommata voneinander getrennt. Definiere eine Variable temperatur mit dem Wert 30 und eine Variable wetter mit dem String 'Es ist warmes Wetter' und gib diese in einer Zeile aus.",
            "startingCode" : "",
            "solution" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\nprint(temperatur, wetter)",
            "output" : "(30, 'Es ist warmes Wetter')"
          }, {
            "index" : 9,
            "description" : "Bei der letzten Aufgabe haben wir gemerkt, dass die Ausgabe mit Klammern und Kommata versehen war, die wir nicht wollen. Man kann mit Python Ausgaben machen, die nur für Strings funktionieren, weshalb wir die nachfolgende Variable y, der ein Integer zugeordnet ist zuerst in einen String umwandeln müssen.<code class=\"python\">x = 'String'\ny = 20\ny = str(y)\nprint(x + y)</code>Verändere nun das Programm aus der letzten Aufgabe, sodass der Output keine Kommata oder Klammern enthält.",
            "startingCode" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\nprint(temperatur, wetter)",
            "solution" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\ntemperatur = str(temperatur)\nprint(temperatur + wetter)",
            "output" : "30Es ist warmes Wetter"
          }, {
            "index" : 10,
            "description" : "Das Problem mit der Ausgabe der letzten Aufgabe war, dass wir mit der Ausgabe der Strings keinen Leerschlag zweischen der Nummer und der Beschreibung haben. Verändere nun den Code der letzten Aufgabe um einen Leerschlag zwischen der Nummer und der Beschreibung zu erhalten.",
            "startingCode" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\ntemperatur = str(temperatur)\nprint(temperatur + wetter)",
            "solution" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\ntemperatur = str(temperatur)\nprint(temperatur + ' ' + wetter)",
            "output" : "30 Es ist warmes Wetter"
          }, {
            "index" : 11,
            "description" : "Benutze nun die vorher gelernten Tools um das Ausgabenformat zu verbessern und schreibe ein Programm, in dem eine Variable windgeschwindigkeit mit dem Wert 120 definiert wird und zweite Variable warnung mit dem String 'Es gibt einen Sturm'. Diese beiden Variablen sollen nun auf einer Zeile ausgegeben werden.",
            "startingCode" : "",
            "solution" : "windgeschwindigkeit = 120\nwarnung = 'Es gibt einen Sturm'\nwindgeschwindigkeit = str(windgeschwindigkeit)\nprint(windgeschwindigkeit + ' ' + warnung)",
            "output" : "120 Es gibt einen Sturm"
          }]
    }, {
      "index" : 2,
      "title" : "Logische Operationen",
      "description" : "Als Logische Operationen bezeichnen wir die Operationen mit den Logischen Operatoren. Diese erfordern als Input einen, oder mehrere (meist zwei) Wahrheitswerte und geben als Output wiederum einen Wahrheitswert, also entweder True oder False, aus. Hier werden die wichtigsten Logischen Operatoren aufgeführt.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Ein Logischer Operator, der nur einen Input braucht, ist der not-Operator, der auch als Komplement bezeichnet wird. Dieser Operator konvertiert den Wahrheitswert einer Aussage oder Variable. Aus True wird also False und aus False wird True. Definiere eine Variable a mit dem Wahrheitswert True und gib diese aus. Wandle sie danach mit dem not-Operator um, indem du einfach a = not a in eine Programmzeile schreibst. Gib die Variable danach erneut aus.",
            "startingCode" : "",
            "solution" : "a = True\nprint(a)\na = not a\nprint(a)",
            "output" : "True\nFalse"
          }, {
            "index" : 1,
            "description" : "Is ist Logischer Operator, mit dem ausgegeben werden kann, ob eine Variable einen bestimmten Wert hat. Dieser Operator wird mit folgendermassen geschrieben:<code class=\"python\">a = 5\nb = a is 5</code>Dabei wird unter b der Wahrheitswert True abgespeichert, weil der Variable a der Wert 5 zugeordnet wurde. Schreibe ein Programm, in dem eine Variable x mit dem Wert 'Koordinate' definiert wird und gib in einer Zeile den Wahrheitswert aus, ob unter x der Wert 5 abgespeichert ist und in der nächsten ob unter x der Wert 'Koordinate' abgespeichert ist.",
            "startingCode" : "",
            "solution" : "x = 'Koordinate'\nprint(x is 5)\nprint(x is 'Koordinate')",
            "output" : "False\nTrue"
          }, {
            "index" : 2,
            "description" : "Der Operator is kann auch als mathematisches Zeichen geschrieben werden. Dieses Zeichen wäre dabei ein doppeltes Gleichheitszeichen (==). Definiere eine Variable q mit dem Wert 5 und frage mit dem is-Operator ab, ob unter der Variable der Wert 2 abgespeichert ist.",
            "startingCode" : "",
            "solution" : "q = 5\nprint(q == 2)",
            "output" : "False"
          }, {
            "index" : 3,
            "description" : "Um zu testen, ob ein Wert kleiner oder grösser als ein anderer Wert ist können wir die dafür vorgesehenen mathematischen Operatoren benutzen. Dabei bedeutet a < b: a kleiner b, a > b: a grösser b, a <= b: a kleiner oder gleich b und a >= b: a grösser oder gleich b. Schreibe ein Programm, welches testet, ob 5 kleiner als 5 ist und gib das Resultat aus.",
            "startingCode" : "",
            "solution" : "a = 5 < 5\nprint(a)",
            "output" : "False"
          }, {
            "index" : 4,
            "description" : "Der and-Operator ist ein Operator, der als Input zwei Argumente, also zwei Wahrheitswerte benötigt. Als Output gibt der and-Operator True aus, wenn beide Wahrheitswerte True waren und False, wenn mindestens eines der Argumente False war. Schreibe ein Programm, welches austestet, ob der vorgegebenen Variable a der Wahrheitswert True zugeordnet ist und ob der Variable b der Wert 7 zugeordnet ist und gib den Output aus.",
            "startingCode" : "a = True\nb = 7",
            "solution" : "a = True\nb = 7\nvalue = a and b == 7\nprint(value)",
            "output" : "True"
          }, {
            "index" : 5,
            "description" : "Schreibe ein Programm, welches den Wahrheitswert dafür ausgibt, ob unter der vorgegebenen Variable a keine 7 abgespeichert ist. Benutze dafür eine Kombination der is und not-Operatoren.",
            "startingCode" : "a = 18",
            "solution" : "a = 18\nbool = a is not 7\nprint(bool)",
            "output" : "True"
          }, {
            "index" : 6,
            "description" : "Die Kombination aus dem is und dem not-Operator kann auch mit einem Operator geschrieben werden: a != 7. Gib den Wahrheitswert dafür aus, dass die vorgegebene Variable  q ungleich 8 und ungleich 9 ist.",
            "startingCode" : "q = 9",
            "solution" : "q = 9\nbool = q != 8 and q != 9\nprint(bool)",
            "output" : "False"
          }, {
            "index" : 7,
            "description" : "Noch ein wichtiger Logischer Operator ist der or-Operator. Dieser Operator steht dabei zwischen zwei Wahrheitswerten und gibt True aus, wenn mindestens einer dieser Wahrheistwerte True ist und False, wenn beide Wahrheitswerte False sind. Verwende einen or-Operator, um zu testen ob unter der vorgegebenen Variable x ein Wert grösser 5 definiert ist, oder ob unter der Variable x ein Wert kleiner 5 definiert ist und gib das Resultat aus.",
            "startingCode" : "x = 5",
            "solution" : "x = 5\na = x > 5 or x < 5\nprint(a)",
            "output" : "False"
          }]
    }, {
      "index" : 3,
      "title" : "If-else-Verzweigungen",
      "description" : "Da wir gelernt haben, Variablen zu definieren und auszugeben und mit logischen Operationen Wahrheitswerte auszugeben, können wir uns anschauen, wie wir diese Verarbeiten können. Dieses Kapitel befasst sich mit if-else-Verzweigungen. Eine if-Verzweigung ist besteht aus einer Bedingung und einem ausführenden Teil. Die Bedingung liefert dabei einen Wahrheitswert, wie wir ihn im letzten Kapitel kennengelernt haben. Falls der Wahrheitswert True ist wird der Teil nach der If-Bedingung ausgeführt. Falls dieser Wahrheitswert False ist wird der Teil nach dem Else ausgeführt. If-else-Verzweigungen werden folgendermassen definiert: <code class=\"python\">a = False\nb = True\nif a:\n\tx = 1\nelif b:\n\tx = 2\nelse:\n\tx = 3</code>Dabei wird also zuerst geschaut, ob a Wahr ist. Wenn nicht wird geschaut, ob b Wahr ist. Wenn nicht, dann wird das else ausgeführt. Da a als False definiert wurde wird dieser Teil übersprungen und da b True ist wird dieser Teil ausgeführt, also wird der Wert 3 der Variable x zugeordnet.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Schreibe ein Programm, welches 'a ist wahr' ausgibt, wenn der vorgegebenen Variable a der Wert True zugeordnet ist.",
            "startingCode" : "a = True",
            "solution" : "a = True\nif a:\n\tprint('a ist wahr')",
            "output" : "a ist wahr"
          }, {
            "index" : 1,
            "description" : "Erweitere das Programm aus der letzten Aufgabe um ein else-Bedingung, sodass 'a ist falsch' ausgegeben wird, wenn die Bedingung nicht erfüllt wurde, also a als False definiert ist.",
            "startingCode" : "a = False\nif a:\n\tprint('a ist wahr')",
            "solution" : "a = False\nif a:\n\tprint('a ist wahr')\nelse:\n\tprint('a ist falsch')",
            "output" : "a ist falsch"
          }, {
            "index" : 2,
            "description" : "Verändere das Programm aus der letzten Aufgabe nun so, dass a durch die Bedingung definiert wird, ob 3 gleichwertig zu 'drei' ist und gib das Resultat um vorgegebenen Format aus.",
            "startingCode" : "a = False\nif a:\n\tprint('a ist wahr')\nelse:\n\tprint('a ist falsch')",
            "solution" : "a = 3 == 'drei'\nif a:\n\tprint('3 ist gleich drei')\nelse:\n\tprint('3 ist ungleich drei')",
            "output" : "3 ist ungleich drei"
          }, {
            "index" : 3,
            "description" : "Modifiziere das Programm aus der letzten Aufgabe so, dass die Zahl 3 mit dem String '3' verglichen wird. Gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "a = 3 == 'drei'\nif a:\n\tprint('3 ist gleich drei')\nelse:\n\tprint('3 ist ungleich drei')",
            "solution" : "a = 3 == '3'\nif a:\n\tprint('3 ist gleich 3')\nelse:\n\tprint('3 ist ungleich 3')",
            "output" : "3 ist ungleich 3"
          }, {
            "index" : 4,
            "description" : "Verändere das Programm nun so, dass es die Zahl 3 mit dem Integerwert vom String '3' vergleicht. Benutze dafür die Funktion int(x), die einen String x in seinen Integerwert umwandelt und gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "a = 3 == '3'\nif a:\n\tprint('3 ist gleich dem Integerwert von 3')\nelse:\n\tprint('3 ist ungleich dem Integerwert von 3')",
            "solution" : "a = 3 == int('3')\nif a:\n\tprint('3 ist gleich dem Integerwert von 3')\nelse:\n\tprint('3 ist ungleich dem Integerwert von 3')",
            "output" : "3 ist gleich dem Integerwert von 3"
          }, {
            "index" : 5,
            "description" : "Der Boolean muss jedoch nicht wie bisher als Variable definiert werden. Er kann auch direkt in der If-else-Verzweigung geschrieben werden: <code class=\"python\">a = 5\nif a == 5:\n\tprint('a hat den Wert 5')</code>Schreibe ein Programm, das testet, ob unter der vorgegebenen Variable x der Wert 9 oder unter der vorgegebenen Variable y der Wert 8 definiert ist und gib das Resultat im vorgegeben Format aus.",
            "startingCode" : "x = 104\ny = 9\nprint('Mindestens eine Bedingung trifft zu')\nprint('Keine Bedingung trifft zu')",
            "solution" : "x = 104\ny = 9\nif x == 9 or y == 8:\n\tprint('Mindestens eine Bedingung trifft zu')\nelse:\n\tprint('Keine Bedingung trifft zu')",
            "output" : "Keine Bedingung trifft zu"
          }, {
            "index" : 6,
            "description" : "Erstelle ein Programm, in dem eine Variable a mit dem Wert 90 definiert wird, teste mit einer If-else-Verzweigung, ob der Variable der Wert 90 zugeordnet ist oder nicht und gibt das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print(str(a) + ' ' + 'ist der Wert 90 zugeordnet')\nprint(str(a) + ' ' + 'ist nicht der Wert 90 zugeordnet')",
            "solution" : "a = 90\nif a == 90:\n\tprint(str(a) + ' ' + 'ist der Wert 90 zugeordnet')\nelse:\n\tprint(str(a) + ' ' + 'ist nicht der Wert 90 zugeordnet')",
            "output" : "90 ist der Wert 90 zugeordnet"
          }, {
            "index" : 7,
            "description" : "Modifiziere die if-else-Verzweigung so, dass das Programm im vorgegebenen Format ausgibt, ob x grösser, gleich oder kleiner als 9 ist.",
            "startingCode" : "x = 9\nif x < 9:\n\tprint('x ist groesser als 9')\nelif x = 13:\n\tprint('x ist gleich 9')\n\n\tprint('x ist kleiner als 9')",
            "solution" : "x = 9\nif x > 9:\n\tprint('x ist groesser als 9')\nelif x == 9:\n\tprint('x ist gleich 9')\nelse:\n\tprint('x ist kleiner als 9')",
            "output" : "x ist gleich 9"
          }, {
            "index" : 8,
            "description" : "Erstelle ein Programm, das die zwei vorgegebenen Variablen x und y vergleicht und das Ergebnis im vorgegebenen Format ausgibt.",
            "startingCode" : "x = 5\ny = 7\nprint('x ist groesser als y')\nprint('x ist gleich y')\nprint('x ist kleiner als y')",
            "solution" : "x = 5\ny = 7\nif x > y:\n\tprint('x ist groesser als y')\nelif x == y:\n\tprint('x ist gleich y')\nelse:\n\tprint('x ist kleiner als y')",
            "output" : "x ist kleiner als y"
          }, {
            "index" : 9,
            "description" : "Erweitere das Programm aus der letzten Aufgabe nun um ein Programm zu estellen, das x mit den beiden vorgegebenen Variablen y und z vergleicht.",
            "startingCode" : "x = 9\ny = 13\nz = 9\nif x > y:\n\tprint('x ist groesser als y und z')\nelif x == y:\n\tprint('x ist gleich y und groesser als z')\nelse:\n\tprint('x ist kleiner als y und gleich z')",
            "solution" : "x = 9\ny = 13\nz = 9\nif x > y:\n\tif x > z:\n\t\tprint('x ist groesser als y und z')\n\telif x == z:\n\t\tprint('x ist groesser als y und gleich z')\n\telse:\n\t\tprint('x ist groesser als y und kleiner als z')\nelif x == y:\n\tif x > z:\n\t\tprint('x ist gleich y und groesser als z')\n\telif x == z:\n\t\tprint('x ist gleich y und z')\n\telse:\n\t\tprint('x ist gleich y und kleiner als z')\nelse:\n\tif x > z:\n\t\tprint('x ist kleiner als y und groesser als z')\n\telif x == z:\n\t\tprint('x ist kleiner als y und gleich z')\n\telse:\n\t\tprint('x ist kleiner als y und z')",
            "output" : "x ist kleiner als y und gleich z"
          }, {
            "index" : 10,
            "description" : "Erstelle ein Programm, dass eine Variable x mit dem Wert 13 definiert und danach testet, ob es sich beim Wert dieser Variable um einen String oder um einen Integer handelt. Verwende dafür die in Python vordefinierten Funktionen str(x) und int(x), wobei x die Variable, deren Datentyp getestet werden soll. Gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print(str(x) + ' ' + 'ist ein Integer')\nprint(str(x) + ' ' + 'ist ein String')",
            "solution" : "x = 13\nif x == int(x):\n\tprint(str(x) + ' ' + 'ist ein Integer')\nif x == str(x):\n\tprint(str(x) + ' ' + 'ist ein String')",
            "output" : "13 ist ein Integer"
          }, {
            "index" : 11,
            "description" : "Erstelle ein Programm, welches den Datentyp der vorgegebenen Variablen x, y und z herausfinden kann und das Ergebnis im vorgegebenen Format ausgibt.",
            "startingCode" : "x = '14'\ny = 41\nz = 123.5\nprint('ist ein Integer')\nprint('ist ein String')\nprint('ist weder ein Integer, noch ein String')",
            "solution" : "x = '14'\ny = 41\nz = 123.5\nif x == int(x):\n\tprint(str(x) + ' ' + 'ist ein Integer')\nelif x == str(x):\n\tprint(str(x) + ' ' + 'ist ein String')\nelse:\n\tprint(str(x) + ' ' + 'ist weder ein Integer, noch ein String')\nif y == int(y):\n\tprint(str(y) + ' ' + 'ist ein Integer')\nelif y == str(y):\n\tprint(str(y) + ' ' + 'ist ein String')\nelse:\n\tprint(str(y) + ' ' + 'ist weder ein Integer, noch ein String')\nif z == int(z):\n\tprint(str(z) + ' ' + 'ist ein Integer')\nelif z == str(z):\n\tprint(str(z) + 'ist ein String')\nelse:\n\tprint(str(z) + ' ' + 'ist weder ein Integer, noch ein String')",
            "output" : "14 ist ein String\n41 ist ein Integer\n123.5 ist weder ein Integer, noch ein String"
          }, {
            "index" : 12,
            "description" : "In der letzten Aufgabe haben wir herausgefunden, dass es auch noch andere Datentyps gibt als nur String und Integer. 123.5 war in diesem Beispiel eine sogenannte Floating Point Zahl. Eine Floating Point Zahl n kann mit int(n) in einen Integer umgewandelt werden. Teste für jede der vorgegebenen Variablen, ob ihnen eine Floating Point Point Zahl zugeordnet ist und gib diese, falls es eine Floating Point Zahl ist im vorgegebenen Format aus. Benutze dafür den Befehl float(n) um eine Zahl beliebigen Datentypes in eine Floating Point Zahl umzuwandeln.",
            "startingCode" : "a = '112'\nb = 4.3623115\nc = 123.0\nd = 124\nprint(str(a) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(a))\nprint(str(b) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(b))\nprint(str(c) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(c))\nprint(str(d) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(d))",
            "solution" : "a = '112.235'\nb = 4.3623115\nc = 123.0\nd = 124\nif a == float(a):\n\tprint(str(a) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(a)))\nif b == float(b):\n\tprint(str(b) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(b)))\nif c == float(c):\n\tprint(str(c) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(c)))\nif d == float(d):\n\tprint(str(d) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(d)))",
            "output" : "4.3623115 ist eine Floating Point Zahl mit dem Integer Wert von 4\n123.0 ist eine Floating Point Zahl mit dem Integer Wert von 123\n124 ist eine Floating Point Zahl mit dem Integer Wert von 124"
          }]
    }, {
      "index" : 4,
      "title" : "While-Schleifen",
      "description" : "Dieses Kapitel befasst sich mit den sogenannten While-Schleifen. Eine While-Schleife in Python sieht folgendermassen aus: <code class=\"python\">while x < 2:\n\tx += 1</code>Hierbei deklariert das Keyword while, dass eine While-Schleife folgt. Nach dem Keyword steht die sogenannte Condition. Sie wird vor jeder Durchführung des Code-Blocks geprüft. Falls diese Condition nicht (mehr) zutrifft, wird die Schleife abgebrochen. Ansonsten wird der folgende Codeblock ausgeführt.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Modifiziere die Schleife so, dass alle ganzen Zahlen von 0 bis und mit 4 ausgegeben werden.",
            "startingCode" : "x = 0\nwhile x < :\n\tprint(x)\n\tx += 1",
            "solution" : "x = 0\nwhile x < 5:\n\tprint(x)\n\tx += 1",
            "output" : "0\n1\n2\n3\n4"
          }, {
            "index" : 1,
            "description" : "Gib ein rechtwinkliges Dreieck bestehend aus Sternen (*) aus, welches aus vier Schichten besteht und dessen jede Schicht immer um einen Stern breiter ist als die Letzte. Die erste Schicht besteht somit aus einem Stern, während die Letzte aus vier besteht.",
            "startingCode" : "x = 1\nwhile x < :\n\tprint()\n\tx += 1",
            "solution" : "x = 1\nwhile x < 5:\n\tprint(x * '*')\n\tx += 1",
            "output" : "*\n**\n***\n****"
          }, {
            "index" : 2,
            "description" : "Erstelle nun selbst eine While-Schleife, welche die Zahlen von 3 bis und mit 9 und je einer Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "x = 3\nwhile x < 10:\n\tprint(x)\n\tx += 1",
            "output" : "3\n4\n5\n6\n7\n8\n9"
          }, {
            "index" : 3,
            "description" : "While-Schleifen können auch mit Variablen des Datentyps Boolean erstellt werden. Ein Boolean hat zwei mögliche Werte, True oder False. Diese Zuordnungen müssen dabei genau so geschrieben werden. Der Boolean stellt also nun die Bedingung dar, die vorher beispielsweise durch x < 5 dargestellt wurde. Modifiziere die Schleife nun so, dass sechs mal in je einer Zeile die Ziffer 7 ausgegeben wird.",
            "startingCode" : "x = 0\nwhile :if x < 7:\n\t\tprint(7)\n\t\tx += 1\n\telse:",
            "solution" : "printing = True\nx = 0\nwhile printing:\n\tif x < 7:\n\t\tprint(7)\n\t\tx += 1\n\telse:\n\t\tprinting = False",
            "output" : "7\n7\n7\n7\n7\n7\n7"
          }, {
            "index" : 4,
            "description" : "Das Zeichen a % b führt die sogenannte Modulo Operation durch. Dabei wird der Rest einer Division von a durch b in den natürlichen Zahlen durchgeführt. Benutze in dieser Aufgabe einen Boolean und die Modulo Operation um eine While-Schleife zu erstellen, die alle durch 7 Teilbaren Zahlen von 13 bis 136 in je einer Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "a = True\nstart = 13\nwhile a:\n\tif start < 136:\n\t\tif start % 7 == 0:\n\t\t\tprint(start)\n\t\tstart += 1\n\telse:\n\t\ta = False",
            "output" : "14\n21\n28\n35\n42\n49\n56\n63\n70\n77\n84\n91\n98\n105\n112\n119\n126\n133"
          }, {
            "index" : 5,
            "description" : "Es kann auch eine While-Schleife innerhalb einer While-Schleife ausgeführt werden. Schreibe ein Programm, das die Zahlen von 1 bis und mit 10, immer mit den zwei nachfolgenden Zahlen, also im Format: 1, 2, 3, 2, 3, 4, 3, 4, 5, 4, 5, 6, ..., 10, 11, 12 mit einer Zahl pro Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "x = 1\nwhile x < 11:\n\ty = x\n\twhile y < x + 3:\n\t\tprint(y)\n\t\ty += 1\n\tx += 1",
            "output" : "1\n2\n3\n2\n3\n4\n3\n4\n5\n4\n5\n6\n5\n6\n7\n6\n7\n8\n7\n8\n9\n8\n9\n10\n9\n10\n11\n10\n11\n12"
          }, {
            "index" : 6,
            "description" : "While-Schleifen können auch an Anwendungsbeispielen eingesetzt werden. Erstelle ein Programm, welches das Kapital auf einem Konto nach 50 Jahren mit einem Jahreszins von 0.05% und einem Startkapital von 100000 Franken berechnet und ausgibt.",
            "startingCode" : "",
            "solution" : "capital = 100000\ninterest = 0.05 / 100\nendTime = 50\ntime = 0\nwhile time <= endTime:\n\tcapital = capital + capital * interest\n\ttime += 1\nprint(capital)",
            "output" : "102582.136882"
          }, {
            "index" : 7,
            "description" : "Erweitere das Programm aus der letzten Aufgabe darum, dass auf das Konto mit gleichen Randbedingnungen (Startkapital 100000 CHF, Jahreszins 0.05%, 50 Jahre Laufzeit) alle fünf Jahre ein Betrag in der Höhe von 10% des momentanen Kontostandes überwiesen wird. Gib das Endkapital nach 50 Jahren aus.",
            "startingCode" : "capital = 100000\ninterest = 0.05 / 100\nendTime = 50\ntime = 0\nwhile time <= endTime:\n\tcapital = capital + capital * interest\n\ttime += 1\nprint(capital)",
            "solution" : "capital = 100000\ninterest = 0.05 / 100\nendTime = 50\ntime = 0\nwhile time * 5 <= endTime:\n\tcounter = 0\n\twhile counter < 6:\n\t\tcapital = capital + capital * interest\n\t\tcounter += 1\n\tcapital += capital * 0.1\n\ttime += 1\nprint(capital)",
            "output" : "294881.599039"
          }]
      }, {
      "index" : 5,
      "title" : "Listen",
      "description" : "Dieses Kapitel befasst sich mit Listen. Eine Liste ist eine Sammlung von geordneten Elementen. Jedem Element ist ein Index zugeordnet, der bei 0 startet und in Einerschritten hoch zählt. Für die Listen gibt es verschiedene Operationen, die Sie in diesem Kapitel kennenlernen werden. Eine Liste wird mit eckigen Klammern gekennzeichnet und die Elemente werden mit Kommata getrennt: <code class=\"python\">a = ['Element 1', 'Element 2']</code>Ein Element aus einer Liste kann herausgegeben werden, indem die Liste und der Index des Elementes in eckigen Klammern geschrieben wird: <code class=\"python\">a[0]</code>",
      "subexercises" : [{
            "index" : 0,
            "description" : "Schreibe ein Programm, dass eine Liste mit der Zahlen 1 bis und mit 10 erstellt und diese Ausgibt.",
            "startingCode" : "",
            "solution" : "a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(a)",
            "output" : "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
          }, {
            "index" : 1,
            "description" : "Mit a.append(Element) wird ein Element ans Ende einer Liste angehängt. Erstelle nun eine Signum Funktion mit If-else-Verzweigungen und einer While-Schleife, die auf die vorgegebene Liste angewendet wird und die Lösung ausgiebt ausgiebt.",
            "startingCode" : "a = [1, 1, -1, -1, 1, 1, -1, 0, 1, -1, 0]\nb = [] ",
            "solution" : "x = 0\na = [2, 5, -2, -8, 4, 100, -12, 0, 1, -4, 0]\nb = []\nwhile x < len(a):\n\tif a[x] > 0:\n\t\tb.append(1)\n\telif a[x] == 0:\n\t\tb.append(0)\n\telse:\n\t\tb.append(-1)\n\tx += 1\nprint(b) ",
            "output" : "[1, 1, -1, -1, 1, 1, -1, 0, 1, -1, 0]"
          }, {
            "index" : 2,
            "description" : "Schreibe ein Programm, mit dem das vierte, das siebte und das achte Element der vorgegebenen Liste b in je einer Zeile ausgegeben wird",
            "startingCode" : "b = [1, 25, -12, -561, 1435, 'asdf', -321,'41', 63, 0]",
            "solution" : "b = [1, 25, -12, -561, 1435, 'asdf', -321,'41', 63, 0]\n# Das 4. Element hat den Index 3, da dieser bei 0 anfängt\nprint(b[3])\nprint(b[6])\nprint(b[7])",
            "output" : "-561\n-321\n41"
          }, {
            "index" : 3,
            "description" : "In Python können auch zwei Listen addiert werden. Wenn a und b zwei Listen sind, dann ergibt die Rechnung c = a + b eine neue Liste c, welche am Anfang die Elemente der Liste a enthält und am Ende die Elemente der Liste b. Gib die Liste aus, die entstehen wird wenn die vorgegebenen Listen a und b addiert werden. Gib in der nächsten Zeile das Ergebnis der Addition von b und a aus.",
            "startingCode" : "a = [1, 6, 2, 8, 7]\nb = [8, 37, 943, 23]",
            "solution" : "a = [1, 6, 2, 8, 7]\nb = [8, 37, 943, 23]\nc = a + b\nprint(c)\nc = b + a\nprint(c)",
            "output" : "[1, 6, 2, 8, 7, 8, 37, 943, 23]\n[8, 37, 943, 23, 1, 6, 2, 8, 7]"
          }, {
            "index" : 4,
            "description" : "Der + Operator sollte jedoch nicht benutzt werden um zwei Listen aneinander zu hängen, da dieser sehr ineffizient arbeitet. Es ist besser für ein einzelnes Element den Operator a.append(n) zu benutzen. Schreibe ein Programm, das die vorgegebenen Listen q und w mithilfe des append() Operators aneinanderhängt und gib die entstandene Liste aus.",
            "startingCode" : "q = [2, 72, 457, 37, 2]\nw = [3, 7, 26, 48, 1]",
            "solution" : "q = [2, 72, 457, 37, 2]\nw = [3, 7, 26, 48, 1]\nq.append(w)\nprint(q)",
            "output" : "[2, 72, 457, 37, 2, [3, 7, 26, 48, 1]]"
          }, {
            "index" : 5,
            "description" : "In der letzten Aufgabe haben wir zwar ein Ergebnis erhalten, jedoch nicht das nicht in der Form, wie wir es mit dem q = q + w erhalten würden. Dieses können wir erhalten, indem wir a.extend(b) benutzen, welcher die Elemente von b am Ende der Liste a einfügt. Füge die Elemente der Liste a am Ende der Liste b ein und gib die bearbeitete Liste b aus.",
            "startingCode" : "a = [3, 73, 48, 3]\nb = [47, 36]",
            "solution" : "a = [3, 73, 48, 3]\nb = [47, 36]\nb.extend(a)\nprint(b)",
            "output" : "[47, 36, 3, 73, 48, 3]"
          }, {
            "index" : 6,
            "description" : "Benutze eine While-Schleife um jedes Element einer Liste, die aus den beiden vorgegebenen Listen x und y besteht zu halbieren und gib die entstehende Liste aus.",
            "startingCode" : "x = [37, 83, 22, 37, 48]\ny = [10, 20, 24]",
            "solution" : "x = [37, 83, 22, 37, 48]\ny = [10, 20, 24]\nz = x + y\na = 0\nwhile a < len(z):\n\tz[a] = float(z[a]) / 2\n\ta += 1\nprint(z)",
            "output" : "[18.5, 41.5, 11.0, 18.5, 24.0, 5.0, 10.0, 12.0]"
          }, {
            "index" : 7,
            "description" : "Schreibe ein Programm, das alle Zahlen in der Liste a, die grösser als 100 sind durch zwei teilt und gib die damit erstellte Liste aus.",
            "startingCode" : "a = [1602, 4, -1005, 125, 36, 72, 252]",
            "solution" : "a = [1602, 4, -1005, 125, 36, 72, 252]\nx = 0\nwhile x < len(a):\n\tif a[x] > 100:\n\t\ta[x] = float(a[x]) / 2\n\tx += 1\nprint(a)",
            "output" : "[801.0, 4, -1005, 62.5, 36, 72, 126.0]"
          }, {
            "index" : 8,
            "description" : "Schreibe ein Programm, das in jeder Zeile eine Liste ausgibt, die in der ersten Zeile das Element 0 enthält, in der zweiten Zeile das Element 0 und das Element 2, und der dritten Zeile das Element 0, das Element 2 und das Element 4. Dieses Muster soll fortgesetzt werden bis zur Liste mit allen geraden Zahlen von 0 bis und mit 16.",
            "startingCode" : "",
            "solution" : "x = 0\na = []\nwhile x <= 16:\n\ta.append(x)\n\tprint(a)\n\tx += 2",
            "output" : "[0]\n[0, 2]\n[0, 2, 4]\n[0, 2, 4, 6]\n[0, 2, 4, 6, 8]\n[0, 2, 4, 6, 8, 10]\n[0, 2, 4, 6, 8, 10, 12]\n[0, 2, 4, 6, 8, 10, 12, 14]\n[0, 2, 4, 6, 8, 10, 12, 14, 16]"
          }, {
            "index" : 9,
            "description" : "Schreibe ein Programm, das die vorgegebene Liste a in zwei Listen aufspaltet, wobei die erste Liste alle negativen Elemente von a enthalten soll und die zweite alle positiven Elemente von a enthalten soll. Die Zahl 0 soll weder in die Liste mit den positiven Zahlen, noch in die Liste mit den negativen Zahlen. Die Ordnung der Elemente soll dabei unverändert bleiben. Gib diese zwei entstandenen Listen in je einer Zeile aus.",
            "startingCode" : "a = [-136, 2347, -478, 0, 47, 8, 0, 13, -26, 5, -58, -3]",
            "solution" : "a = [-136, 2347, -478, 0, 47, 8, 0, 13, -26, 5, -58, -3]\nb = []\nc = []\nx = 0\nwhile x < len(a):\n\tif a[x] < 0:\n\t\tb.append(a[x])\n\telif a[x] > 0:\n\t\tc.append(a[x])\n\tx += 1\nprint(b)\nprint(c)",
            "output" : "[-136, -478, -26, -58, -3]\n[2347, 47, 8, 13, 5]"
          }, {
            "index" : 10,
            "description" : "Bisher haben wir nur Elemente an das Ende einer Liste hinzugefügt. Man kann jedoch ein Element auch an einem beliebigen Index zu einer Liste hinzufügen. Dies kann mit der Funktion a.insert(i, n), wobei das Element n am Index i zur Liste a hinzugefügt wird. Füge der vorgegebenen Liste a in der Mitte das Element 'Mitte' ein und gibt die Liste aus.",
            "startingCode" : "a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
            "solution" : "a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\na.insert(len(a) / 2, 'Mitte')\nprint(a)",
            "output" : "[1, 2, 3, 4, 5, 'Mitte', 6, 7, 8, 9, 10]"
          }, {
            "index" : 11,
            "description" : "Wenn wir ein Element in einer Liste a haben, dessen Index wir erfahren wollen, können wir diesen mit der Methode a.index(n) herausfinden. Gib den Index des Elementes Mitte aus der vorgegebenen Liste b aus.",
            "startingCode" : "b = [1, 2, 3, 4, 5, 'Mitte', 6, 7, 8, 9, 10]",
            "solution" : "b = [1, 2, 3, 4, 5, 'Mitte', 6, 7, 8, 9, 10]\nindex = b.index('Mitte')\nprint(index)",
            "output" : "5"
          }, {
            "index" : 12,
            "description" : "Die Methode a.index(n) gibt nur den Index des ersten Elementes mit dem Wert n aus, falls mehrere enthalten sind. Jedoch kann der Methode ein zweites Argument hinzugefügt werden, nämlich der Startwert für den Index, ab welchem gesucht werden soll. Eine Suche nach einem Element mit dem Wert 5 in einer Liste q ab dem Index 3 würde also folgendermassen aussehen:<code class=\"python\">q.index(5, 3)</code>Gib den Index des zweiten Elementes mit dem Wert 18 aus der Liste z aus.",
            "startingCode" : "z = [1, 18, 25, 37, 12, 34, 18, 26, 16, 18]",
            "solution" : "z = [1, 18, 25, 37, 12, 34, 18, 26, 16, 18]\nindex_0 = z.index(18)\nindex_1 = z.index(18, index_0 + 1)\nprint(index_1)",
            "output" : "6"
          }, {
            "index" : 13,
            "description" : "Es können aber nicht nur Elemente zu einer Liste hinzugefügt werden, es können auch Elemente entfernt werden. Dafür kann die Funktion a.remove(n) gebraucht werden. Mit a.remove(n) wird das erste Element aus der Liste a, das den Wert n hat entfernt. Entferne die ersten drei Elemente mit den Wert 1 aus der vorgegebenen Liste list und gibt die modifizierte Liste aus.",
            "startingCode" : "list = [1, 26, 26, 1, 36, 372, 58, 1, 4, 1, 48, 1]",
            "solution" : "list = [1, 26, 26, 1, 36, 372, 58, 1, 4, 1, 48, 1]\nx = 0\nwhile x < 3:\n\tlist.remove(1)\n\tx += 1\nprint(list)",
            "output" : "[26, 26, 36, 372, 58, 4, 1, 48, 1]"
          }, {
            "index" : 14,
            "description" : "Um herauszufinden, ob ein Wert in einer Liste enthalten ist, kann das Schüsselwort in verwendet werden. Der folgende Code testet, ob in der Liste numbers ein Element mit dem Wert 'two' enthalten ist<code class=\"python\">a = 'two' in numbers</code>und ordnet der Variable a einen Boolean zu, also entweder True, wenn 'two' enthalten ist, oder False, wenn nicht. Schreibe ein Programm, in welchem du in je einer Zeile ausgibst, ob die Werte 2, 61, 3, 'wonder' oder 6 in der Liste p enthalten sind.",
            "startingCode" : "p = [3, 24, 'wonders', 52, 61, 36, 3]",
            "solution" : "p = [3, 24, 'wonders', 52, 61, 36, 3]\nprint(2 in p)\nprint(61 in p)\nprint(3 in p)\nprint('wonder' in p)\nprint(52 in p)\nprint(61 in p)\nprint(6 in p)",
            "output" : "False\nTrue\nTrue\nFalse\nTrue\nTrue\nFalse"
          }, {
            "index" : 15,
            "description" : "Die range(n) Funktion erzeugt eine Liste, wobei die einzelnen Elemente die ganzen Zahlen von 0 bis (aber ohne) zum Wert n sind. Erzeige damit eine Liste a mit den Werten von 0 bis und mit 12 und gib diese aus.",
            "startingCode" : "",
            "solution" : "a = range(13)\nprint(a)",
            "output" : "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]"
          }, {
            "index" : 16,
            "description" : "Erzeuge mit der range(n) Funktion eine Liste der zahlen von 0 bis und mit 8. Gib diese aus und verändere sie mithilfe einer While-Schleife zu einer Liste von 10 bis und mit 18 und gib sie wieder aus.",
            "startingCode" : "",
            "solution" : "a = range(9)\nprint(a)\nx = 0\nwhile x < len(a):\n\ta[x] += 10\n\tx += 1\nprint(a)",
            "output" : "[0, 1, 2, 3, 4, 5, 6, 7, 8]\n[10, 11, 12, 13, 14, 15, 16, 17, 18]"
          }, {
            "index" : 17,
            "description" : "Das in der letzten Aufgabe erreichte Ergebnis kann auch einfacher erzeugt werden, indem man den Startwert der range(n) Funktion verändert. Diesen kann man erreichen, indem man der Funktion einen zweiten Input gibt, der vor dem ersten Input steht. Das erste Element (mit dem Index 0) wird dann den Wert dieses Inputs annehmen. Erzeuge damit eine Liste der Zahlen von 112 bis und mit 115 und gib diese aus.",
            "startingCode" : "",
            "solution" : "a = range(112, 116)\nprint(a)",
            "output" : "[112, 113, 114, 115]"
          }, {
            "index" : 18,
            "description" : "Nun wollen wir aber nicht nur Listen mit aufeinanderfolgenden Zahlen erstellen. Erstelle mit der Range-Funktion eine Liste der Zahlen von 10 bis und mit 15 und gib diese aus. Modifiziere diese Liste danach in einer While-Schleife, sodass sie die die geraden Zahlen zwischen 10 und (mit) 20 enthält.",
            "startingCode" : "",
            "solution" : "a = range(10, 16)\nprint(a)\nx = 0\nwhile x < len(a):\n\ta[x] += x\n\tx += 1\nprint(a)",
            "output" : "[10, 11, 12, 13, 14, 15]\n[10, 12, 14, 16, 18, 20]"
          }, {
            "index" : 19,
            "description" : "Wie schon in der vorletzten Aufgabe hält die Range-Funktion auch beim Problem der letzten Aufgabe eine Lösung bereit. Die Lösung besteht darin, dass man der Range-Funktion noch ein drittes Argument geben kann, welches die Schrittlänge bestimmt. Dieses muss einfach ganzzahlig sein. Erstelle mit der Range-Funktion eine Liste aller durch drei Teilbaren Zahlen zwischen 1 und 29.",
            "startingCode" : "",
            "solution" : "a = range(1 + 2, 29, 3)\nprint(a)",
            "output" : "[3, 6, 9, 12, 15, 18, 21, 24, 27]"
          }, {
            "index" : 20,
            "description" : "Da die Voraussetzung für die Schrittlänge lediglich lautet, dass sie ganzzahlig sein muss kann mit einer Range-Funktion auch eine Liste erstellt werden, bei der Zahlen in absteigender Reihenfolge aufgelistet sind. Erstelle eine Liste mit den geraden Zahlen von 35 bis 17 und gib diese aus.",
            "startingCode" : "",
            "solution" : "a = range(35 - 1, 17, -2)\nprint(a)",
            "output" : "[34, 32, 30, 28, 26, 24, 22, 20, 18]"
          }, {
            "index" : 21,
            "description" : "Wir können auch einen Wort, also einen String in die einzelnen Buchstaben aufteilen und daraus eine Liste erstellen. Bei einem String können die einzelnen Elemente (Buchstaben) genau gleich ausgewählt werden wir bei einer Liste:<code class=\"python\">a = 'Hallo'\nb = a[0]\nprint(b)</code>Dieser Code würde den String 'H' ausgeben. Schreibe ein Programm, mit dem das Wort 'Programm' in eine Liste, bei der jeder Buchstabe ein Element ist einsetzt und gib diese Liste aus.",
            "startingCode" : "a = 'Programm'",
            "solution" : "a = 'Programm'\nb = []\nfor i in range(len(a)):\n\tb.append(a[i])\nprint(b)",
            "output" : "['P', 'r', 'o', 'g', 'r', 'a', 'm', 'm']"
          }, {
            "index" : 22,
            "description" : "Die Operation aus der vorgerigen Aufgabe kann auch umgekehrt werden. Dies funktioniert aber nur mit Elementen mit dem Datentyp String, aber nicht mit Integer-Elementen. Zum zusammenfügen muss die join-Methode verwendet werden.<code class=\"python\">a = ['q', 'w']\nb = str(''.join(a))</code>Dieser Code erstellt einen String 'qw'. Was vor dem join in den Anführungszeichen steht ist, was eingefügt wird zwischen den einzelnen Elementen. Füge die vorgegebene Liste von Zahlen zu einer Zahl zusammen und gib diese aus.",
            "startingCode" : "z = [15, 247, 1, 34, 25]",
            "solution" : "z = [15, 247, 1, 34, 25]\nx = 0\nwhile x < (len(z)):\n\tz[x] = str(z[x])\n\tx += 1\na = int(''.join(z))\nprint(a)",
            "output" : "1524713425"
          }]
      }, {
      "index" : 6,
      "title" : "For-Schleifen",
      "description" : "Dieses Kapitel befasst sich mit den sogenannten For-Schleifen. Eine For-Schleife in Python sieht normalerweise so aus: <code class=\"python\">for x in [1, 6, 2]:\n\tprint(x)</code>Hierbei deklariert das Schlagwort for, dass eine For-Schleife folgt. Die For-Schleife startet dann mit dem ersten Wert der Liste und arbeitet sich bis zum Letzten durch. Dabei nimmt die Variable, die nach dem Schlagwort for folgt den Wert des jeweiligen Elementes an.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Benutze eine For-Schleife, um jedes Element der Liste a je einer Zeile auszugeben.",
            "startingCode" : "a = [1, 3, 235, 2, 63, 1, 8, 459, 238]",
            "solution" : "a = [1, 3, 235, 2, 63, 1, 8, 459, 238]\nfor element in a:\n\tprint(element)",
            "output" : "1\n3\n235\n2\n63\n1\n8\n459\n238"
          }, {
            "index" : 1,
            "description" : "Schreibe eine Liste mit den Zahlen 1, 6, 25, 2 und 4 direkt in eine For-Schleife und gibt die Zahlen einzeln ein je einer Zeile aus.",
            "startingCode" : "",
            "solution" : "for i in [1, 6, 25, 2, 4]:\n\tprint(i)",
            "output" : "1\n6\n25\n2\n4"
          }, {
            "index" : 2,
            "description" : "Erstelle mit der Range-Funktion eine Liste mit den Zahlen von 0 bis und mit 10 und gib die Elemente dieser Liste mit einer For-Schleife aus.",
            "startingCode" : "",
            "solution" : "a = range(0, 11)\nfor i in a:\n\tprint(i)",
            "output" : "0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10"
          }, {
            "index" : 3,
            "description" : "Gib nun die geraden Zahlen zwischen 300 und 309 in je einer Zeile aus, indem du die Range-Funktion direkt in die For-Schleife hineinschreibst.",
            "startingCode" : "",
            "solution" : "for i in range(300, 309, 2):\n\tprint(i)",
            "output" : "300\n302\n304\n306\n308"
          }, {
            "index" : 4,
            "description" : "Benutze das Schlagwort in, sowie if-else Verzweigungen um eine Liste mit den Elementen, die sowohl in der Liste a, als auch in der Liste b enthalten sind, sowie eine Liste mit den Elementen, die in a aber nicht in b und eine Liste mit den Elementen in b aber nicht in a. Gib diese Listem im vorgegebenen Format aus und behalte die Reihenfolge der Elemente bei.",
            "startingCode" : "a = [1, 6, 2, 3, 7]\nb = [4, 3, 6, 2, 9, 8]\nprint('In a und b' + ' ' + str(ab))\nprint('Nur in a' + ' ' + str(aa))\nprint('Nur in b' + ' ' + str(bb))",
            "solution" : "a = [1, 6, 2, 3, 7]\nb = [4, 3, 6, 2, 9, 8]\naa = []\nab = []\nbb = []\nfor i in a:\n\tif i in b:\n\t\tab.append(i)\n\telse:\n\t\taa.append(i)\nfor i in b:\n\tif i not in a:\n\t\tbb.append(i)\nprint('In a und b' + ' ' + str(ab))\nprint('Nur in a' + ' ' + str(aa))\nprint('Nur in b' + ' ' + str(bb))",
            "output" : "In a und b [6, 2, 3]\nNur in a [1, 7]\nNur in b [4, 9, 8]"
          }, {
            "index" : 5,
            "description" : "Erstelle mit der Range-Funktion eine Liste aller durch 7 teilbaren Zahlen zwischen 1 und 106. Benutze diese Liste nun um aus der vorgegebenen Liste a alle Zahlen zu entfernen, die nicht durch 7 teilbar sind und setzte an deren Stelle eine 0 ein. Gib die modifizierte Liste a aus.",
            "startingCode" : "a = [2, 6, 7, 36, 42, 84, 39, 105, 49]",
            "solution" : "a = [2, 6, 7, 36, 42, 84, 39, 105, 49]\ntest_7 = range(1 + 6, 106, 7)\nfor i in a:\n\tif i not in test_7:\n\t\ta.insert(a.index(i), 0)\n\t\ta.remove(i)\nprint(a)",
            "output" : "[0, 0, 7, 0, 42, 84, 0, 105, 49]"
          }, {
            "index" : 6,
            "description" : "Ob eine Zahl durch eine andere Zahl teilbar ist, können wir auch herausfinden, indem wir die Zahl in den ganzen Zahlen durch den Nenner teilen und das Ergebnis mit der Division in den Fliesskommazahlen vergleichen. Um eine Teilung in den Fliesskommazahlen zu ermöglichen müssen wir die Zahl zuerst mit float(n) in eine Fliesskommazahl umwandeln, respektive sie für eine Teilung in den ganzen Zahlen mit int(n) in einen Integer umwandeln. Teste für jedes Element der Liste q, ob es durch 3 Teilbar ist und entferne es, falls dies der fall ist. Gib danach die bearbeitete Liste q aus.",
            "startingCode" : "q = [1245, 3621, 2342, 48222, 2363, 36]",
            "solution" : "q = [1245, 3621, 2342, 48222, 2363, 36]\na = range(len(q))\nfor i in a:\n\tif int(q[i]) / 3 == float(q[i]) / 3:\n\t\tq.remove(q[i])\n\t\t# Die Liste a, mit der q untersucht wird muss\n\t\t# verändert werden, da q verändert wurde\n\t\tfor j in range(len(a)):\n\t\t\ta[j] -= 1\nprint(q)",
            "output" : "[2342, 2363]"
          }, {
            "index" : 7,
            "description" : "Um zu testen, ob eine Zahl a durch eine Zahl b teilbar ist können wir aber auch einen Operator benutzen. Dieser Operator wird mit dem Prozentzeichen geschrieben und nennt sich Modulo-Operator. Die Operation a % b gibt dabei den Rest auch, den wir bei einer Teilung von a durch in den ganzen Zahlen erhalten. Schreibe ein Programm, das für jedes Element der vorgegebenen Liste q testet, ob das Element durch seinen Index + 1 teilbar ist und ersetze es durch den String 'nicht teilbar', falls dies nicht zutrifft.",
            "startingCode" : "q = [26, 36, 135, 17, 257, 354, 42]",
            "solution" : "q = [26, 36, 135, 17, 257, 354, 42]\nfor i in q:\n\tif i % (q.index(i) + 1) != 0:\n\t\tq[index(i)] = 'nicht teilbar'\nprint(q)",
            "output" : "[26, 36, 135, 'nicht teilbar', 'nicht teilbar', 354, 42]"
          }]
      }, {
      "index" : 7,
      "title" : "Zahlensysteme",
      "description" : "In diesem Kapitel werden wir uns mit den verschiedenen Zahlensystemen befassen. Der Hauptfokus wird dabei auf die Binärzahlen gelegt, jedoch werden auch die Hexadezimalzahlen anschgeschaut, da diese auch noch sehr häufig verwendet werden. Gefordert wird dabei, dass das die Dezimalzahlen grundlegend verstanden wurden.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Das Zahlensystem, welches normalerweise im Alltag verwendet wird ist das sogenannte Dezimalsystem. Dabei werden die Ziffern von 0 bis 9 verwendet. Wenn wir nun eine Zahl haben, können die Ziffern von 0 bis 9 beliebig angeordnet werden. Jede Ziffer wird nun mit einem Faktor multipliziert, der folgendermassen von ihrer Position abhängt: Die Ziffer ganz links wird mit 10**0 multipliziert, die zweite von links mit 10**1, die dritte von links mit 10**2, ... und die n-te von links mit 10**(n-1). Schreibe ein Programm, in welchem die Zahl 12456 als einzelne Faktoren, in der Form 1 * 10**4 in je einer Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "a = 12456\n# Die Zahl wird in einen String umgewandelt, damit die\n# einzelnen Ziffern ausgewählt werden können\na = str(a)\n# Jede Ziffer wird mit dem dazugehörigen Faktor ausgegeben\nfor i in range(len(a)):\n\tprint(a[i] + ' * ' + '10**' + str(len(a) - (i + 1)))",
            "output" : "1 * 10**4\n2 * 10**3\n4 * 10**2\n5 * 10**1\n6 * 10**0"
          }, {
            "index" : 1,
            "description" : "In einem Computer kann das Dezimalsystem aber schlecht verwendet werden, da der Computer nicht direkt zwischen den zehn verschiedenen Ziffern des Dezimalsystems unterscheiden kann. Der Computer kann nur eine Unterscheidung von zwei Ziffern machen, also Strom fliesst oder Strom fliesst nicht, was auf die Ziffern 0 oder 1 abgeleitet werden kann. Deswegen wird ein neues System gebraucht, das sogenannte Binärsystem. Dabei können nur noch die Ziffern 0 und 1 verwendet werden. Auch hier wird wieder jede Ziffer mit einem von der Position abhängenden Faktor multipliziert, jedoch nicht mehr mit der Basis 10, sondern der Basis 2: die erste von links wird mit 2**0 multipliziert, die zweite mit 2**1, ... und die n-te mit 2**(n-1). Schreibe ein Programm, das die Binärzahl 100101 als einzlene Faktoren, in der Form 1 * 2**5 in je einer Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "a = 100101\n# Die Zahl wird in einen String umgewandelt, damit die\n# einzelnen Ziffern ausgewählt werden können\na = str(a)\n# Jede Ziffer wird mit dem dazugehörigen Faktor ausgegeben\nfor i in range(len(a)):\n\tprint(a[i] + ' * ' + '2**' + str(len(a) - (i + 1)))",
            "output" : "1 * 2**5\n0 * 2**4\n0 * 2**3\n1 * 2**2\n0 * 2**1\n1 * 2**0"
          }, {
            "index" : 2,
            "description" : "Ein Computer muss nun aber die Zahlen aus dem Binärsystem ins Dezimalsystem umwandeln. Schreibe ein Programm, das die Werte der vorgegebenen Variablen x und y, bei denen es sich um Binärzahlen handelt, als Dezimalzahlen ausgibt.",
            "startingCode" : "x = 10101101110\ny = 10100010101",
            "solution" : "x = 10101101110\ny = 10100010101\n# Die Zahlen werden in Strings umgewandelt, damit die\n# einzelnen Ziffern ausgewählt werden können\nx = str(x)\ny = str(y)\nx_dez = 0\n# Jede einzelne Ziffer wird mit dem Faktor multipliziert\nfor i in range(len(x)):\n\tx_dez += int(x[i]) * 2 ** (len(x) - (i + 1))\nprint(x_dez)\ny_dez = 0\nfor i in range(len(y)):\n\ty_dez += int(y[i]) * 2 ** (len(y) - (i + 1))\nprint(y_dez)",
            "output" : "1390\n1301"
          }, {
            "index" : 3,
            "description" : "In Python können Binärzahlen aber auch einfacher in Dezimalzahlen umgewandelt werden. Dafür kann a = 0b111 gebraucht werden, wobei 111 die Binärzahl. Dabei wird der Variable a der Wert der Binärzahl als Dezimalzahl zugeordnet, es ist nun also die Zahl 7 unter der Variable a abgespeichert. Wandle die Binärzahlen 11001010 und 101010001 in Dezimalzahlen um und gibt sie in je einer Zeile aus.",
            "startingCode" : "",
            "solution" : "a = 0b11001010\nprint(a)\nb = 0b101010001\nprint(b)",
            "output" : "202\n337"
          }, {
            "index" : 4,
            "description" : "Schreibe nun ein Programm, welches eine Zahl aus dem Dezimalsystem ins Binärsystem umwandeln kann. Wandle damit die Zahlen 171 und 402 in Binärzahlen um und gib die jeweiligen Ergebnisse in je einer Zeile aus.",
            "startingCode" : "",
            "solution" : "a = [171, 402]\n# Das Programm wird auf beide Zahlen angewandt\n# Es wird eine Liste mit jeder Ziffer erstellt\nfor i in a:\n\tb = []\n\t# Zuerst muss die höchste Potenz gefunden werden\n\tx = True\n\ty = 0\n\twhile x:\n\t\tif i <= 2 ** (y + 1):\n\t\t\ti -= 2 ** y\n\t\t\tb.append(1)\n\t\t\tx = False\n\t\telse:\n\t\t\ty += 1\n\t# Jetzt werden die nachfolgenden Ziffern bestimmt\n\tfor k in range(y - 1, -1, -1):\n\t\tif i >= 2 ** k:\n\t\t\ti -= 2 ** k\n\t\t\tb.append(1)\n\t\telse:\n\t\t\tb.append(0)\n\t# Der Datentyp der Elemente der Liste wird in String\n\t# umgewandelt\n\tfor i in range(len(b)):\n\t\tb[i] = str(b[i])\n\t# Die Elemente der Liste werden aneinandergehängt\n\tb = int(''.join(b))\n\tprint(b)",
            "output" : "10101011\n110010010"
          }, {
            "index" : 5,
            "description" : "Für die umwandlung von Zahlen aus dem Dezimalsystem ins Binärsystem gibt es in Python bereits eine vordefinierte Methode. So kann mit bin(n) die Dezimalzahl n ins Binärsystem umgewandelt werden. Schreibe ein Programm, das die Zahlen 20194 und 2401 ins Binärsystem umwandelt und diese in je einer Zeile ausgibt.",
            "startingCode" : "a = 20194\nb = 2401",
            "solution" : "a = 20194\nb = 2401\naBin = bin(a)\nbBin = bin(b)\nprint(aBin)\nprint(bBin)",
            "output" : "0b100111011100010\n0b100101100001"
          }, {
            "index" : 6,
            "description" : "Wenn wir nun aber mit Operationen mit diesen Binärzahlen durchführen möchten stört uns das 0b am Anfang der Zahl. Schreibe ein Programm, welches die Dezimalzahl 2048 in das Binärsystem umwandelt und gib die Binärzahl ohne das 0b vorne dran aus.",
            "startingCode" : "a = 2048",
            "solution" : "a = 2048\naBin = str(bin(a))\naList = []\n# Der String wird in eine Liste umgewandelt\nfor i in aBin:\n\taList.append(i)\n# Das 0 und das b werden aus der Liste entfernt\naList.remove('0')\naList.remove('b')\n# Die Liste wird wieder zurück in einen String umgewandelt\nresult = ''.join(aList)\nprint(result)",
            "output" : "100000000000"
          }]
      }, {
      "index" : 8,
      "title" : "Funktionen",
      "description" : "Dieses Kapitel befasst sich mit Funktionen. Eine Funktion in Python sieht folgendermassen aus: <code class=\"python\">def a(x, y):\n\tz = x + y\n\treturn z\nprint(a(1, 3)))</code>Dabei wird nach def eine Funktion mit den Variablen x und y definiert (er können beliebig viele Varbiablen sein, durch Kommata getrennt). Die Funktion wird dann mit a(1, 3) aufgerufen und ausgeführt und mit return wird die Ausgabe ausgegeben, die danach ausserhalb gebraucht werden kann.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Definiere eine Funktion, welche die zwei vorgegebenen Variablen x und y multipliziert und das Ergebnis ausgibt.",
            "startingCode" : "x = 124\ny = 41",
            "solution" : "x = 124\ny = 41\ndef a(x, y):\n\tz = x * y\n\treturn z\nprint(a(x, y))",
            "output" : "5084"
          }, {
            "index" : 1,
            "description" : "Definiere eine Funktion, welche den Betrag einer Zahl berechnen kann. Tipp: Exponenten werden mit a ** x, also a hoch x geschrieben.",
            "startingCode" : "x = -24",
            "solution" : "x = -24\ndef Betrag(x):\n\ty = (x ** 2) ** 0.5\n\treturn y\nprint(Betrag(x))",
            "output" : "24.0"
          }, {
            "index" : 2,
            "description" : "Definiere eine Funktion, die ausgeben kann, ob der vorgegebenen Variable p eine Primzahl zugeordent ist. Gebe das Resultat im vorgegebenen Format aus.",
            "startingCode" : "p = 120431\nprint(str(p) + ' ist keine Primzahl')\nprint(str(p) + ' ist eine Primzahl')",
            "solution" : "p = 120431\ndef isprime(p):\n\tb = True\n\t# Eine for-Schleife, die für jede Zahl kleiner p,\n\t# grösser 1 testet, ob sie ein Teiler ist\n\tfor i in range(2, p, 1):\n\t\t# Wenn die Zahl Teilbar ist, dann ist p keine Primzah\n\t\tif p % i == 0:\n\t\t\tprint(str(p) + ' ist keine Primzahl')\n\t\t\tb = False\n\t\t\tbreak\n\t# Wenn kein Teiler gefunden wurde ist b eine Primzahl\n\tif b == True:\n\t\tprint(str(p) + ' ist eine Primzahl')\n\treturn\nisprime(p)",
            "output" : "120431 ist eine Primzahl"
          }, {
            "index" : 3,
            "description" : "Erweitere nun die Funktion aus der letzten Aufgabe, um eine Funktion zu finden, die eine Liste mit allen Primzahlen zwischen den Zahlen 124 und 190 erstellt und diese ausgibt.",
            "startingCode" : "def isprime(p):\n\tb = True\n\tfor i in range(2, p, 1):\n\t\tif p % i == 0:\n\t\t\tprint(str(p) + ' ist keine Primzahl')\n\t\t\tb = False\n\t\t\tbreak\n\tif b == True:\n\t\tprint(str(p) + ' ist eine Primzahl')\nisprime(p)",
            "solution" : "def listprime(x, y):\n\tc = [('Primzahlen zwischen ' + str(x) + ' und ' + str(y))]\n\t# Eine For-Schleife um alle Zahlen zwischen x und y\n\t# durchzugehen\n\tfor k in range(x, y, 1):\n\t\tb = True\n\t\tfor i in range(2, k, 1):\n\t\t\tif k % i == 0:\n\t\t\t\tb = False\n\t\t\t\tbreak\n\t\tif b == True:\n\t\t\tc.append(k)\n\treturn c\nprint(listprime(124, 190))",
            "output" : "['Primzahlen zwischen 124 und 190', 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181]"
          }, {
            "index" : 4,
            "description" : "Definiere eine Funktion mit der vorgegebenen Liste a als Input, die das kleinste Element der Liste ausgibt. Benutze dafür eine For-Schleife. Tipp: Die Elemente einer Liste sind als Strings abgespeichert. Um sie zu vergleichen müssen sie erst mit int(a) in Integer umgewandelt werden.",
            "startingCode" : "a = [1, 5, 2, 5, 2, 1, 623, -213, 2135, 6, -13, 261, -36, 66]",
            "solution" : "a = [1, 5, 2, 5, 2, 1, 623, -213, 2135, 6, -13, 261, -36, 66]\ndef minimum(a):\n\tx = int(a[0])\n\tfor element in a:\n\t\tif x > int(element):\n\t\t\tx = int(element)\n\treturn x\nprint(minimum(a))",
            "output" : "-213"
          }, {
            "index" : 5,
            "description" : "Definiere eine Funktion, die alle Zahlen aus der vorgegeben Liste x der Grösse nach (vom kleinsten zum grössten) sortiert. Mehrfach vorkommende Zahlen sollen dabei hintereinander aufgelistet werden.",
            "startingCode" : "x = [1, 2357, 234, 347, 3246, 2132, 23, 7, -23, -32, 7, 26]",
            "solution" : "x = [1, 2357, 234, 347, 3246, 2132, 23, 7, -23, -32, 7, 26]\ndef sort(x):\n\tfor q in range(len(x)):\n\t\tfor i in range(len(x)):\n\t\t# Wenn das Element mit dem kleineren Index\n\t\t# grösser ist wird es getauscht\n\t\t\tif x[len(x) - q - i - 1] < x[len(x) - q - 1]:\n\t\t\t\ta = x[len(x) - q - i - 1]\n\t\t\t\tx[len(x) - q - i - 1] = x[len(x) - q - 1]\n\t\t\t\tx[len(x) - q - 1] = a\n\treturn x\nprint(sort(x))",
            "output" : "[-32, -23, 1, 7, 7, 23, 26, 234, 347, 2132, 2357, 3246]"
          }, {
            "index" : 6,
            "description" : "Bei dieser Aufgabe geht es wieder um Primzahlen. Jede Zahl kann mit ihren sogenannten Primfaktoren, also Primzahlen, die multipliziert die Zahl gegen dargestellt werden. Definiere also eine Funktion, mit der du als Input eine Zahl erhältst und als Output eine Liste der Primfaktoren erhältst, geordnet von der kleinsten zur grössten. Gibt damit die Primfaktoren der vorgegebenen Werten von x und y aus.",
            "startingCode" : "x = 28340\ny = 104500",
            "solution" : "x = 28340\ny = 104500\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\nprint(primefactors(x))\nprint(primefactors(y))",
            "output" : "[2, 2, 5, 13, 109]\n[2, 2, 5, 5, 5, 11, 19]"
          }, {
            "index" : 7,
            "description" : "Die Aufspaltung einer Zahl in ihre Primfaktoren kann gebraucht werden um die Teiler der Zahl herauszufinden. Dabei sind also die Primfaktoren selbst auf jeden Fall Teiler, aber auch alle möglichen Multiplikationen der einzelnen Primfaktoren. Definiere nun eine zweite Funktion, die eine Liste aller Teiler (ohne 1) erstellt und gib damit alle Teiler, geordnet vom kleinsten zum grössten Teiler, der Zahl 124 aus. Die Funktion sollte für Zahlen mit bis zu  vier Primfaktoren funktionieren.",
            "startingCode" : "x = 124\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "x = 124\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef dividers(n):\n\tfactors = primefactors(n)\n\tdivider = []\n\tfor i in range(len(factors)):\n\t\t# Alle Primfaktoren sind Teiler von n\n\t\tdivider.append(factors[i])\n\t\tfor j in range(i + 1, len(factors), 1):\n\t\t\tdivider.append(factors[i] * factors[j])\n\t\t\tfor k in range(j + 1, len(factors), 1):\n\t\t\t\tdivider.append(factors[i] * factors[j] *\n\t\t\t\t  factors[k])\n\t\t\t\tfor l in range(k + 1, len(factors), 1):\n\t\t\t\t\tdivider.append(factors[i] * factors[j]\n\t\t\t\t\t  * factors[k] * factors[l])\n\t# Doppelte Teiler werden entfernt\n\tx = 0\n\twhile x < len(divider):\n\t\ty = x + 1\n\t\twhile y < len(divider):\n\t\t\tif divider[x] == divider[y]:\n\t\t\t\tdivider.remove(divider[x])\n\t\t\telse:\n\t\t\t\ty += 1\n\t\tx += 1\n\t# Die Liste wird der Grösse nach geordnet\n\tfor i in range(len(divider)):\n\t\tfor j in range(i, len(divider), 1):\n\t\t\tif divider[i] > divider[j]:\n\t\t\t\tdivider[i], divider[j] = divider[j], divider[i]\n\treturn divider\n\nprint(dividers(x))",
            "output" : "[2, 4, 31, 62, 124]"
          }, {
            "index" : 8,
            "description" : "In dieser Aufgabe wollen wir die Primfaktorenzerlegung dazu benutzen um den grössten gemeinsamen Teiler zweier Zahlen zu finden. Dieser ist dabei das Produkt aller Primfaktoren, die in beiden Zahlen vorhanden sind. Benutze also die Funktion für die Primfaktorenzerlegung und berechne mit einer neuen Funktion den grössten gemeinsamen Teiler der Zahlen 1520 und 3730 und gib ihn aus.",
            "startingCode" : "a = 1520\nb = 3730\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "a = 1520\nb = 3730\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\tfor w in range(10):\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef ggT(a, b):\n\tfactors_a = primefactors(a)\n\tfactors_b = primefactors(b)\n\t# Testen welche Faktoren in beiden vorkommen\n\tfactors_both = []\n\tfor i in range(len(factors_a)):\n\t\tfor j in range(len(factors_b)):\n\t\t\tif factors_a[i] == factors_b[j]:\n\t\t\t\tfactors_both.append(factors_a[i])\n\t\t\t\t# Das gebrauchte Element wird ersetzt,\n\t\t\t\t# damit es nur einmal gebraucht wird\n\t\t\t\tfactors_a[i] = 0\n\tggT = 1\n\tfor i in range(len(factors_both)):\n\t\tggT *= factors_both[i]\n\treturn ggT\n\nprint(ggT(a, b))",
            "output" : "80"
          }, {
            "index" : 9,
            "description" : "Das Gegenstück zum ggT ist das kgV, das kleinste gemeinsame Vielfache zweier Zahlen. Dieses kann auch mithilfe der Primfaktoren bestimmt werden. Dabei müssen alle Primfaktoren von der ersten Zahl mit allen Primfaktoren der zweiten Zahl, ausgenommen der Primfaktoren, die bereits in der ersten Zahl vorgekommen sind multipliziert werden um das kgV zu erhalten. Definiere eine Funktion, die das kgV zweier Zahlen berechnet und gib damit das kgV von 108 und 261 aus.",
            "startingCode" : "a = 108\nb = 261\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "a = 108\nb = 261\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef kgV(a, b):\n\tfactors_a = primefactors(a)\n\tfactors_b = primefactors(b)\n\t# Die beiden Listen werden aneinandergehängt\n\tfactors_both = factors_a + factors_b\n\tfor i in range(len(factors_a)):\n\t\tfor j in range(len(factors_b)):\n\t\t\tif factors_a[i] == factors_b[j]:\n\t\t\t\tfactors_both.remove(factors_a[i])\n\t\t\t\t# Das gebrauchte Element wird ersetzt,\n\t\t\t\t# damit es nur einmal gebraucht wird\n\t\t\t\tfactors_a[i] = 0\n\tkgV = 1\n\tfor i in range(len(factors_both)):\n\t\tkgV *= factors_both[i]\n\treturn kgV\n\nprint(kgV(142, 261))",
            "output" : "1044"
          }, {
            "index" : 10,
            "description" : "Die Aufstpaltung in die Primfaktoren kann auch sehr behilflich sein beim Vereinfachen von Brüchen. Definiere eine Funktion, die den Bruch (Format als Liste [Zähler, Nenner]) [2620, 3660] vollständig vereinfacht und ausgibt.",
            "startingCode" : "a = [2620, 3660]\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "a = [2620, 3660]\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schleife\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef simplifier(fraction):\n\ta = fraction[0]\n\tb = fraction[1]\n\tfactors_a = primefactors(a)\n\tfactors_b = primefactors(b)\n\ti = 0\n\twhile i < len(factors_a):\n\t\tj = 0\n\t\twhile j < len(factors_b):\n\t\t\tif factors_a[i] == factors_b[j]:\n\t\t\t\tfactors_a.remove(factors_a[i])\n\t\t\t\tfactors_b.remove(factors_b[j])\n\t\t\telse:\n\t\t\t\tj += 1\n\t\ti += 1\n\ta = 1\n\tfor i in range(len(factors_a)):\n\t\ta *= factors_a[i]\n\tb = 1\n\tfor i in range(len(factors_b)):\n\t\tb *= factors_b[i]\n\treturn [a, b]\n\nprint(simplifier(a))",
            "output" : "[131, 183]"
          }, {
            "index" : 11,
            "description" : "Um die Lösung dieser Aufgabe zu verstehen solltest du mit den sogenannten Binärzahlen vertraut sein. Falls du dies noch nicht bist schaue dir bitte zuerst das Kapitel zu den Zahlensystemen an. Es geht darum ein sogenanntes Powerset der vorgegebenen Liste a zu erstellen. Ein Powerset ist die Gesamtheit aller möglichen Kombinationen der Elemente einer Liste (die Reihenfolge ist dabei jedoch egal). Gib jedes einzelne Element (als Liste) des Powersets der vorgegebenen Liste a in je einer Zeile aus und behalte dabei die Reihenfolge der originalen Liste bei.",
            "startingCode" : "a = [1, 7, 23, 25, 37]",
            "solution" : "a = [1, 7, 23, 25, 37]\ndef powerset(a):\n\t# Das Powerset besteht aus 2 hoch n Subsets\n\tfor i in range(2 ** len(a)):\n\t\t# Die Dezimalzahl wird in eine Binärzahl umgewandelt\n\t\tbinary = bin(i)\n\t\t# Die Binärzahl muss als String abgespeichert sein,\n\t\t# damit sie verändert werden kann\n\t\tbinary = str(binary)\n\t\t# Der String wird in eine Liste aufgespalten\n\t\tbinaryList = []\n\t\tfor t in binary:\n\t\t\tbinaryList.append(t)\n\t\t# Das 0b wird aus der Liste entfernt\n\t\tbinaryList.remove('0')\n\t\tbinaryList.remove('b')\n\t\t# Die Liste der Binärzahl wird auf n-Bits erweitert\n\t\temptyBits = []\n\t\tfor i in range(len(a) - len(binaryList)):\n\t\t\temptyBits.insert(0, '0')\n\t\t# Die beiden Listen werden zusammengefügt\n\t\tbinaryList = emptyBits + binaryList\n\t\t# Die Subsets werden nach der Anordung der\n\t\t# Binärzahlen erstellt\n\t\tsubSet = []\n\t\tfor k in range(len(binaryList)):\n\t\t\tif binaryList[k] == '1':\n\t\t\t\tsubSet.append(a[k])\n\t\tprint(subSet)\npowerset(a)",
            "output" : "[]\n[37]\n[25]\n[25, 37]\n[23]\n[23, 37]\n[23, 25]\n[23, 25, 37]\n[7]\n[7, 37]\n[7, 25]\n[7, 25, 37]\n[7, 23]\n[7, 23, 37]\n[7, 23, 25]\n[7, 23, 25, 37]\n[1]\n[1, 37]\n[1, 25]\n[1, 25, 37]\n[1, 23]\n[1, 23, 37]\n[1, 23, 25]\n[1, 23, 25, 37]\n[1, 7]\n[1, 7, 37]\n[1, 7, 25]\n[1, 7, 25, 37]\n[1, 7, 23]\n[1, 7, 23, 37]\n[1, 7, 23, 25]\n[1, 7, 23, 25, 37]"
          }]
      }, {
      "index" : 9,
      "title" : "Rekursive Funktionen",
      "description" : "Rekursive Funktionen werden genau gleich wie normale Funktionen definiert. Sie haben aber die Eigenschaft, dass Sie in der Funktion selbst aufgerufen wird. Wenn also eine Funktion sich selber aufruft wird sie noch einmal durchgeführt und ruft sich wieder selbst auf. Wenn das immer so weiter gehen würde, dann hätten wir eine unendliche Schleife kreiert. Deswegen müssen wir in der Rekursiven Funktion eine Abbruchbedingung einbauen. Die Funktion wird mit dem Codewort return a abgebrochen und gibt den Wert der Variable aus. Das unten stehende Beispiel beinhaltet eine Funktion, die eine Zahl a solange um eins erhöht, bis a den gleichen Wert wie b hat und dann abbricht und a ausgibt.<code class=\"python\">def function(a, b):\n\t# Abbruchbedingung\n\tif a >= b:\n\t\treturn a\n\telse:\n\t\ta += 1\n\t\t# Funktion wird erneut\n\t\t# aufgerufen\n\t\tfunction(a, b)</code>",
      "subexercises" : [{
            "index" : 0,
            "description" : "Definiere eine rekursive Funktion, die die Zahlen von 3 bis und mit 18 ausgibt.",
            "startingCode" : "",
            "solution" : "a = 3\nb = 19\ndef printer(a, b):\n\tif a < b:\n\t\tprint(a)\n\t\ta += 1\n\t\tprinter(a, b)\n\telse:\n\t\treturn\nprinter(a, b)",
            "output" : "3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18"
          }, {
            "index" : 1,
            "description" : "Rekursive Funktionen können auch dazu genutzt werden um rekursive Folgen auszugeben. Nun betrachten wir die Folge die wie folgt definiert ist: a_0 = 0, a_n+1 = 1 / 3* a_n + 12. Definiere eine rekursive Funktion, die eine Liste erstellt in der die ersten 10 Elemente der Funktion enthalten sind und gib diese Liste aus.",
            "startingCode" : "",
            "solution" : "a = [0]\ndef folge(n, i):\n\tif i >= n:\n\t\tprint(a)\n\t\treturn a\n\telse:\n\t\ta.append(a[i] * 1 / 3 + 12)\n\t\ti += 1\n\t\tfolge(n, i)\nfolge(9, 0)",
            "output" : "[0, 12, 16, 17, 17, 17, 17, 17, 17, 17]"
          }, {
            "index" : 2,
            "description" : "Verändere das Programm aus der letzten Aufgabe nun so, dass die Funktion ein Argument erhält, mit dem ein Index n ausgewählt werden kann. Dadurch soll das Element aus der Folge mit diesem Index ausgegeben werden. Beachte, dass das erste Element den Index 0 hat. Gib für n = 10, n = 16, n = 153 das Element der Folge a_0 = 51, a_n+1 = 1.1 * a_n - 14 aus.",
            "startingCode" : "n = 10\nn = 23624\na_0 = 51\ndef folge(n, i):\n\tif i >= n:\n\t\treturn a\n\telse:\n\t\ta.append(a[i] * 1 / 3 + 12)\n\t\ti += 1\n\t\tfolge(n, i)\nprint(folge(10, 0))",
            "solution" : "n = 10\na_0 = 51\ndef folge(n, i, a):\n\tif i >= n:\n\t\tprint(a)\n\t\treturn a\n\telse:\n\t\ta = a * 1.1 - 14\n\t\ti += 1\n\t\tfolge(n, i, a)\nfolge(n, 0, a_0)\nn = 16\nfolge(n, 0, a_0)\nn = 153\nfolge(n, 0, a_0)",
            "output" : "-90.8430789489\n-268.952595786\n-191633097.108"
          }, {
            "index" : 3,
            "description" : "Eine andere, rekursiv sehr einfach darstellbare Folge ist die sogenannte Fibonacci-Folge. Diese ist so definiert, dass die ersten beiden Elemente beide den Wert 1 haben und jedes weitere Element aus der Summe der beiden vorangehenden Elemente besteht. Gib die ersten 50 Werte der Fibonacci Folge in je einer Zeile aus.",
            "startingCode" : "",
            "solution" : "a = 1\nb = 1\ndef fibonacci(a, b, n, i):\n\tif i >= n:\n\t\treturn\n\telse:\n\t\tif i % 2 == 0:\n\t\t\tprint(a)\n\t\t\ta += b\n\t\telse:\n\t\t\tprint(b)\n\t\t\tb += a\n\t\ti += 1\n\t\tfibonacci(a, b, n, i)\nfibonacci(a, b, 50, 0)",
            "output" : "1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n46368\n75025\n121393\n196418\n317811\n514229\n832040\n1346269\n2178309\n3524578\n5702887\n9227465\n14930352\n24157817\n39088169\n63245986\n102334155\n165580141\n267914296\n433494437\n701408733\n1134903170\n1836311903\n2971215073\n4807526976\n7778742049\n12586269025"
          }, {
            "index" : 4,
            "description" : "Im leztzen Kapitel haben wir angeschaut, wie der grösste gemeinsame Teiler, der ggT zweier Zahlen mit einer iterativen Funktion berechnet werden kann. Schreibe nun eine rekursive Funktion und berechne damit den grössten gemeinsamen Teiler der Zahlen 2590 und 25025 und gib ihn aus. Tipp: Benutze dafür den Modulo-Operator (%), der den Rest einer Teilung zweier Zahlen in den ganzen Zahlen ausgibt.",
            "startingCode" : "a = 2590\nb = 25025",
            "solution" : "a = 2590\nb = 25025\n# Gibt den ggT der Integer a und b aus\ndef ggT(a, b):\n\t# Abbruchbedingung, wenn a durch b Teilbar ist, also die beiden\n\t# Zahlen auf den gleichen Wert gebracht wurden\n\tif b == 0:\n\t\t# Der ggT wird ausgegeben\n\t\tprint(a)\n\t\treturn a\n\t# Die Funktion wird erneut aufgerufen\n\tggT(b, a % b)\nggT(a, b)",
            "output" : "34"
          }]
      }, {
      "index" : 10,
      "title" : "Module",
      "description" : "Dieses Kapitel befasst sich mit Modulen. In einem Modul können Variablen und hauptsächlich Funktionen gespeichert werden. In python gibt es auch Module, die bereits definiert sind, jedoch noch importiert werden müssen. Dies kann man mit import time machen, wobei time der Name des Modules ist. Um eine Funktion aus dem Modul aufzurufen muss man time.time(), also den Namen des Modules . den Namen der Funktion. In diesem Kapitel geht es hauptsächlich um die Module math und time.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Importiere das Modul math und gib den Sinus von 45 Grad aus. Beachte, dass der Winkel im Bogenmass werden muss. Mit math.sin(a) kannst du den Sinus eines Winkels ausgeben und mit math.asin() kannst du den Arcussinus einer Zahl ausgeben. Runde das Resultat mit round(x, 5) auf fünf Stellen nach dem Komma und gib es aus",
          "startingCode" : "",
          "solution" : "import math\n# Die Variable pi wird mit der Kreiszahl definiert\npi = math.asin(1) * 2\na = math.sin(45 * 2 * pi / 360)\nprint(round(a, 5))",
          "output" : "0.70711"
          }, {
            "index" : 1,
            "description" : "Importiere das Modul time. Mit time.time() kannst du nun eine Zeit in Sekunden ausgeben. Finde nun heraus, in welchem Jahr diese Zeit ihren Ursprung (also 0 war) hatte. Tipp: mit int(a) wir eine floating point Zahl in einen Integer umgewandelt, also eine Dezimalzahl zu einer ganzen Zahl abgerundet.",
            "startingCode" : "",
            "solution" : "import time\n# Die Zeit wird von Sekunden in Jahre konvertiert\nnow = time.time() / (60 * 60 * 24 * 365.24)\n# Die Zeit wird von 2020 (Ende 2019) abgezogen, um das Ursprungsjahr zu erhalten\nzero = 2020 - now\nyear = int(zero)\nprint(year)",
            "output" : "1970"
          }, {
            "index" : 2,
            "description" : "Ein Modul kann auch mit<code class=\"python\">from time import *</code>importiert werden. Dabei kann anstelle von time ein beliebiges Modul importiert werden. Der Vorteil davon ist, dass nun die Funktionen des Moduls nicht mehr mit time.time(), sondern nur noch mit time() aufgerufen werden können. Importiere das Modul math und gib mithilfe der Funktionen log(x, Basis) und e (Eulersche Zahl) den natürlichen Logarithmus von 3.5 aus. Runde diesen mit round(x, 4) auf vier Stellen nach dem Komma.",
            "startingCode" : "",
            "solution" : "from math import *\na = log(3.5, e)\na_rounded = round(a, 4)\nprint(a_rounded)",
            "output" : "1.2528"
          }, {
            "index" : 3,
            "description" : "Teste mithilfe des Moduls time, ob in Python 20 multipliziert 20 oder ob 20 hoch 2 schneller gerechnet wird. Tipp: Lass die Rechnung einige Male laufen, da das Ergebnis sonst zu ungenau ist. Gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print('20 mal 20 mal 20 mal 20 wird schneller gerechnet')\nprint('20 hoch 4 wird schneller gerechnet')",
            "solution" : "from time import *\nt0 = time()\nfor i in range(100000):\n\t20 * 20 * 20 * 20\nt_multiply = time() - t0\nt0 = time()\nfor i in range(100000):\n\t20 ** 4\nt_power = time() - t0\nif t_multiply < t_power:\n\tprint('20 mal 20 mal 20 mal 20 wird schneller gerechnet als 20 hoch 4')\nelse:\n\tprint('20 hoch 4 wird schneller gerechnet als 20 mal 20 mal 20 mal 20')",
            "output" : "20 hoch 4 wird schneller gerechnet als 20 mal 20 mal 20 mal 20"
          }, {
            "index" : 4,
            "description" : "Teste in diesem Programm, ob es einen Unterschied in der gebrauchten Zeit zwischen den beiden Möglichkeiten eine Addition durchzuführen: x = x + n oder x += n. Denke daran mehrere Durchläufe zu machen um ein vertrauliches Ergebnis zu erhalten und gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print('Die Operation x = x + n ist schneller')\nprint('Es sind beide Operationen etwa gleich schnell')\nprint('Die Operation x += n ist schneller')",
            "solution" : "from time import *\nx = 0\nt0 = time()\nfor i in range(1500000):\n\tx = x + 10\nt_fullwritten = time() - t0\nx = 0\nt0 = time()\nx = 0\nfor i in range(1500000):\n\tx += 10\nt_shortwritten = time() - t0\nif abs(t_fullwritten - t_shortwritten) < t_fullwritten / 100:\n\tprint('Es sind beide Operationen etwa gleich schnell')\nelif t_fullwritten < t_shortwritten:\n\tprint('Die Operation x = x + n ist schneller')\nelse:\n\tprint('Die Operation x += n ist schneller')",
            "output" : "Die Operation x = x + n ist schneller"
          }, {
            "index" : 5,
            "description" : "Teste nach dem gleichen Prinzip wie vorher, ob eine While-Schleife oder eine For-Schleife schneller durchlaufen wird. Denke wieder daran, dies mit genug vielen Durchlaufen zu testen und gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print('Eine For-Schleife ist schneller als eine While-Schleife')\nprint('Eine While-Schleife ist schneller als eine For-Schleife')",
            "solution" : "from time import *\nt0 = time()\nfor i in range(1000000):\n\t1000 * 1000\nt_for = time() - t0\nt0 = time()\nx = 0\nwhile x < 1000000:\n\t1000 * 1000\n\tx = x + 1\nt_while = time() - t0\nif t_for < t_while:\n\tprint('Eine For-Schleife ist schneller als eine While-Schleife')\nelse:\n\tprint('Eine While-Schleife ist schneller als eine For-Schleife')",
            "output" : "Eine For-Schleife ist schneller als eine While-Schleife"
          }, {
            "index" : 6,
            "description" : "Mit dem Modul random können zufällig Zahlen in einer vorgegebenen Reichweite generiert werden. Dabei gibt es verschiedene Funktionen, die im Beispielcode gezeigt und im Kommentar dazu beschrieben werden.<code class=\"python\"># Das Random-Modul wird importiert\nfrom random import *\n# Generiert eine zufällige ganze Zahl\n# zwischen 4 und (ohne) 9\nrandint(4, 9)\n# Generiert eine zufällige Fliess-\n# kommazahl zwischen 3 und (ohne) 7\nuniform(3, 7)\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Durchmischt die Liste x\nshuffle(x)\n# Nimmt ein zufälliges Element aus\n# der Liste\nchoice([1, 5, 2, 7, 36, 7, 26, 2])</code>Schreibe ein Programm, welches eine Lottoziehung ausführen kann. Dabei werden zufällig sechs verschiedene Zahlen aus den ersten 42 natürlichen Zahlen gezogen. Zusätzlich wird noch die Glückszahl zufällig aus den ersten sechs natürlichen Zahlen gezogen. Das Programm soll eine Liste mit den gezogenen Zahlen in aufsteigender Reihenfolge und die Glückszahl ausgeben. Falls es funktioniert gib lediglich den String 'Abgeschlossen' aus.",
            "startingCode" : "",
            "solution" : "from random import *\nnumbers = range(43)\nluckyNumbers = range(7)\n# Es wird sechs mal eine Zahl aus der Liste numbers gezogen\nresult = []\nfor i in range(6):\n\t# Die gezogene Nummer wird abgespeichert unter temp\n\ttemp = choice(numbers)\n\t# Die gezogenen Nummer wird aus der Nummernliste entfernt\n\tnumbers.remove(temp)\n\tresult.append(temp)\n# Die Glückszahl wird aus luckyNumbers gezogen\nluckyNumber = choice(luckyNumbers)\n# print(str(result) + ' ' + str(luckyNumber))\nprint('Abgeschlossen')",
            "output" : "Abgeschlossen"
          }, {
            "index" : 7,
            "description" : "Teste mithilfe des Moduls time, ob es sich mehr Lohnt 1000 * 1000 zu rechnen, oder ob es schneller ist 1000 ** 2 zu rechnen. Gib das Resultat im vorgegebenen Format aus. Nimm für beide etwa gleich schnell einen Unterschied von bis zu 1% der Durchlaufzeit.",
            "startingCode" : "print('1000 ** 2 ist schneller')\nprint('1000 * 1000 ist schneller')\nprint('Beide sind etwa gleich schnell')",
            "solution" : "from time import *\nt_0 = time()\nfor i in range(1000000):\n\t1000 * 1000\nt_multiply = time() - t_0\nt_0 = time()\nfor i in range(1000000):\n\t1000 ** 2\nt_power = time() - t_0\nif t_power < 0.99 * t_multiply:\n\tprint('1000 ** 2 ist schneller')\nelif t_multiply < 0.99 * t_power:\n\tprint('1000 * 1000 ist schneller')\nelse:\n\tprint('Beide sind etwa gleich schnell')",
            "output" : "1000 * 1000 ist schneller"
          }, {
            "index" : 8,
            "description" : "Im Kapitel der Listen haben wir zwei Methoden kennen gelernt um zwei Listen zusammenzufügen. Die eine Methode war x = x + y und die andere x.extend(y). Teste mit dem Modul time, welche der beiden Operationen schneller ist. Nimm für gleich schnell einen Unterschied von bis zu einem Prozent der Durchlaufzeit. Gib den Output im vorgegebenen Format aus.",
            "startingCode" : "print('Mit + geht es schneller als mit extend')\nprint('Es sind beide Operationen etwa gleich schnell')\nprint('Mit extend geht es schneller als mit +')",
            "solution" : "from time import *\nz = [15, 247, 1, 34, 25]\ny = [15, 247, 1, 34, 25]\nt0 = time()\nfor i in range(5000):\n\tz = z + y\nt_add = time() - t0\nz = [15, 247, 1, 34, 25]\nt0 = time()\nfor i in range(5000):\n\tz.extend(y)\nt_extend = time() - t0\nif t_add < 0.99 * t_extend:\n\tprint('Mit + geht es schneller als mit extend')\nelif t_add > 0.99 * t_extend and t_extend > 0.99 * t_add:\n\tprint('Es sind beide Operationen etwa gleich schnell')\nelse:\n\tprint('Mit extend geht es schneller als mit +')",
            "output" : "Mit extend geht es schneller als mit +"
          }]
      }, {
      "index" : 11,
      "title" : "Klassen Einführung",
      "description" : "Dieses Kapitel befasst sich mit Klassen. Falls du mit den Funktionen noch nicht sattelfest bist empfehlen wir dir, zuerst diese Kapitel durchzuarbeiten, bevor du dich an die Klassen wagst. Klassen werden in Python folgendermassen definiert.<code class=\"python\">class calculator:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\tdef sum(self):\n\t\tself.sum = self.x + self.y\n\t\treturn self.sum\ninput = calculator(2, 3)\nsumme = calculator.sum(input)\nprint(summe)</code>Am obigen Beispiel ist also erkennbar, dass eine Klasse eine Sammlung von Funktionen sein kann. Immer dabei sein muss ein __init__(self, Argument 1, Argument 2, ...). Durch diese Funktion werden die verschiedenen Eigenschaften einer Variable definiert. Wenn die Klasse nun aufgerufen wird mit n = name(Argument 1, Argument 2, ...) dann kann in der Funktion __init__ der Variable n mit n.eigenschaft = Argument 1, einer Eigenschaft von n ein Wert zugeordnet werden. Dieser kann dann in den weiteren Funktionen der Klasse aufgerufen und verarbeitet werden. Die weiteren Funktionen werden mit name.funktionsname(Argument 1, ...) aufgerufen.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Kopiere oder Schreibe das Programm aus der Kapitelbeschreibung ab füge noch ein drittes Argument z = 8 hinzu. Addiere nun die drei Werte und gib das Resultat aus.",
            "startingCode" : "z = 8",
            "solution" : "z = 8\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\ninput = calculator(2, 3, z)\nsumme = calculator.sum(input)\nprint(summe)",
            "output" : "13"
          }, {
            "index" : 1,
            "description" : "Erweitere nun das Programm aus der letzten Aufgabe um zu dem Summenrechner noch einen Produktrechner hinzuzufügen. Addiere die drei vorgegebenen Variablen nun mit der Klasse, gib das Ergebnis aus und Multipliziere die Variablen mit der Klasse und gib das Ergebnis auf einer neuen Zeile aus.",
            "startingCode" : "x = 15\ny = 25\nz = 23\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\ninput = calculator(2, 3, z)\nsumme = calculator.sum(input)\nprint(summe)",
            "solution" : "x = 15\ny = 25\nz = 23\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\tproduct()\n\t\tGibt das Produkt der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Argumente aus'''\n\t\tself.product = self.x * self.y * self.z\n\t\treturn self.product\ninput = calculator(x, y, z)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "output" : "63\n8625"
          }, {
            "index" : 2,
            "description" :"Erweitere dass Programm der letzzen Aufgabe nun so, dass es eine Liste von mit Zahlen als Input nimmt. Gib die Summe und das Produkt der zwei vorgegebenen Variablen x und y in je einer Zeile aus.",
            "startingCode" : "x = 155\ny = 162\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\tproduct()\n\t\tGibt das Produkt der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Argumente aus'''\n\t\tself.product = self.x * self.y * self.z\n\t\treturn self.product\ninput = calculator(x, y, z)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "solution" : "x = 15\ny = 25\nlist = [x, y] # Liste mit den Elementen x und y\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe der Elemente vom Attribut aus'''\n\t\tself.sum = self.a[0] + self.a[1]\n\t\treturn self.sum\n\t\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = self.a[0] * self.a[1]\n\t\treturn self.product\ninput = calculator(list)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "output" : "40\n375"
          }, {
            "index" : 3,
            "description" :"Erweitere dass Programm der letzten Aufgabe jetzt so, dass es eine Liste aus egal wie vielen Elementen als Input nehmen kann. Berechne damit die Summe und die Produkte aller Zahlen aus den zwei vorgegebenen Liste. Gibt die Ergebnisse in je einer Zeile und der Reihenfolge: Summe 1, Produkt 1, Summe 2, Produkt 2 aus.",
            "startingCode" : "x = [1, 164, 126, 1246, 62, 62, 168, 690, 951] # Liste als Input\ny = [399, 6, 27, 2, 7, 1, 2, 36, 6, 25] # Liste als Input\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe der Elemente vom Attribut aus'''\n\t\tself.sum = self.a[0] + self.a[1]\n\t\treturn self.sum\n\t\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = self.a[0] * self.a[1]\n\t\treturn self.product\ninput = calculator(list)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "solution" : "x = [1, 164, 126, 1246, 62, 62, 168, 690, 951] # Liste als Input\ny = [399, 6, 27, 2, 7, 1, 2, 36, 6, 25] # Liste als Input\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe aller Elemente vom Attribut aus'''\n\t\tself.sum = 0\n\t\tfor i in range(len(self.a)):\n\t\t\tself.sum += self.a[i]\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = 1\n\t\tfor i in range(len(self.a)):\n\t\t\tself.product *= self.a[i]\n\t\treturn self.product\ninput_1 = calculator(x)\nsumme_1 = calculator.sum(input_1)\nprint(summe_1)\nProdukt_1 = calculator.product(input_1)\nprint(Produkt_1)\ninput_2 = calculator(y)\nsumme_2 = calculator.sum(input_2)\nprint(summe_2)\nProdukt_2 = calculator.product(input_2)\nprint(Produkt_2)",
            "output" : "3470\n10910752488817413120\n511\n9773265600"
          }, {
            "index" : 4,
            "description" :"Nun wollen wir den Taschenrechner mit einer Funktion erweitern, die ihn die Fakultät eines Inputs rechnen lässt. Gib die Fakultäten der Elemente der vorgegebenen Liste x in je einer Zeile aus. Beachte dafür dass die Fakultät von 0 per Definition 1 ist.",
            "startingCode" : "x = [22, 0, 12]\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe aller Elemente vom Attribut aus'''\n\t\tself.sum = 0\n\t\tfor i in range(len(self.a)):\n\t\t\tself.sum += self.a[i]\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus\n\t'''\n\t\tself.product = 1\n\t\tfor i in range(len(self.a)):\n\t\t\tself.product *= self.a[i]\n\t\treturn self.product\ninput_1 = calculator(x)\nsumme_1 = calculator.sum(input_1)\nprint(summe_1)\nProdukt_1 = calculator.product(input_1)\nprint(Produkt_1)\ninput_2 = calculator(y)\nsumme_2 = calculator.sum(input_2)\nprint(summe_2)\nProdukt_2 = calculator.product(input_2)\nprint(Produkt_2)",
            "solution" : "x = [22, 0, 12]\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : int\n\t\tEin Wert zum rechnen\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\tfactorial()\n\t\tGibt die Fakultaet vom aufgerufenen Element aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : int\n\t\t\tEine Zahl, die als Attribut definiert wird\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe der Elemente vom Attribut aus'''\n\t\tself.sum = 0\n\t\tfor i in range(len(self.a)):\n\t\t\tself.sum += self.a[i]\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = 1\n\t\tfor i in range(len(self.a)):\n\t\t\tself.product *= self.a[i]\n\t\treturn self.product\n\tdef factorial(self, element):\n\t\t'''Gibt die Fakultaet des Elementes vom Attribut aus'''\n\t\tself.factorial = 1\n\t\tfor i in range(self.a[element]):\n\t\t\tself.factorial *= self.a[element] - i\n\t\treturn self.factorial\nfor i in range(len(x)):\n\tprint(calculator.factorial(calculator(x), i))",
            "output" : "1124000727777607680000\n1\n479001600"
          }]
      }, {
      "index" : 12,
      "title" : "Klassen Fortgeschritten",
      "description" : "Wenn dir die Einführung in die Klassen zu leicht ist, du dich aber trotzdem mit Klassen beschäftigen willst, dann empfehlen wir dir dieses Kapitel. Wenn du dich jedoch noch nie mit Klassen befasst hast empfehlen wir dir das letzte Kapitel, die Einführung in die Klassen.",
      "subexercises" : [{
            "index" : 0,
            "description" : "Definiere eine Klasse, die in der Lage ist die Gravitationskraft zwischen zwei Objekten nach dem Newtonschen Gravitationsgesetz zu berechenen. Benutze dafür die vorgegebenen und gib die Kraft auf die Masse_1 zuerst und in der darauffolgenden Zeile die Kraft auf die Masse_2 aus. Runde die Kräfte mit round(x, 4) auf 4 Stellen nach dem Komma.",
            "startingCode" : "mass_1 = 15000 # Masse in kg\nmass_2 = 37500 # Masse in kg\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\ndistance = 0.05 # Distanz (m)",
            "solution" : "mass_1 = 15000 # Masse in kg\nmass_2 = 37500 # Masse in kg\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\ndistance = 0.05 # Distanz (m)\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tzwei Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tdistance : int\n\t\tDie Distanz zu dem interagierenden Objekt\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\t'''\n\tdef __init__(self, mass, distance):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\t\tDie Masse des Objektes\n\t\tdistance : int\n\t\t\tDie Distanz zu dem interagierenden Objekt\n\t\t'''\n\t\tself.mass = mass\n\t\tself.distance = distance\n\tdef force(self, interactor_mass):\n\t\t'''Gibt die Kraft auf das Objekt aus'''\n\t\tforce = (G * self.mass * interactor_mass /\n\t  self.distance ** 2)\n\t\treturn force\nobject_1 = gravitation(mass_1, distance)\nobject_2 = gravitation(mass_2, distance)\nforce_1 = gravitation.force(object_1, object_2.mass)\nforce_2 = gravitation.force(object_2, object_1.mass)\nprint(round(force_1, 4))\nprint(round(force_2, 4))",
            "output" : "15.0165\n15.0165"
          }, {
            "index" : 1,
            "description" : "Definiere eine Klasse, die folgende Operationen mit n-dimensionalen Vektoren durchführen kann: Addition mit einem Vektor, Multiplikation mit einer Konstante, Länge des Vektors (magnitude), Einheitsvektor (norm). Gib die Länge des Vektor_1, der Richtungsvektor des Vektor_2, das Produkt von 3 und dem Vektor_3 und die Addition von Vektor_2 und Vektor_4 in je einer Zeile aus. Runde die Zahlen mit der bereits implementierten Funktion round(x, 4). Beachte dabei, dass du nur skalare Werte addieren, runden oder multiplizieren kannst.",
            "startingCode" : "vector_1 = [1, 7, 156]\nvector_2 = [6, 262, 2]\nvector_3 = [1, 0, 25]\nvector_4 = [6, 26, 291]",
            "solution" : "vector_1 = [1, 7, 156]\nvector_2 = [6, 262, 2]\nvector_3 = [1, 0, 25]\nvector_4 = [6, 26, 291]\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors (Richtungsvektor)\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den normierten Vektor aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\nvec1 = vectorcalculator(vector_1)\nvec2 = vectorcalculator(vector_2)\nvec3 = vectorcalculator(vector_3)\nvec4 = vectorcalculator(vector_4)\nprint(round(vectorcalculator.magnitude(vec1), 4))\nprint(vectorcalculator.norm(vec2))\nprint(vectorcalculator.multiplication(vec3, 3))\nprint(vectorcalculator.addition(vec2, vector_4))",
            "output" : "156.1602\n[0.0229, 0.9997, 0.0076]\n[3, 0, 75]\n[12, 288, 293]"
          }, {
            "index" : 2,
            "description" : "In der ersten Aufgabe haben mit einer Klasse die Gravitationskraft zwischen zwei Objekten berechnet. Wir wollen der Klasse nun beliebig viele Objekte als Input geben. Deswegen können wir auch nicht mehr eine skalare Zahl als Distanz Input nehmen, sondern wir brauchen vektorielle Positionen. Diese werden mit einer Liste [x, y, z] gegeben. Tipp: alle Objekte wirken Gravitationskräfte auf alle Objekte aus, verwende also eine Liste für self.interactors. Gib die Kräfte auf die einzelnen Objekte der Indexe nach geordnet in je einer Zeile aus und runde sie mit round(x, 4) auf vier Stellen nach dem Komma. Verwende für die Berechnungen die Klasse für das Vektorenrechnen aus der letzten Aufgabe.",
            "startingCode" : "mass_1 = 236 # Masse in kg\nmass_2 = 339 # Masse in kg\nmass_3 = 3079 # Masse in kg\nmass_4 = 306 # Masse in kg\nposition_1 = [1, 5, 2] # Position [x, y, z] (m)\nposition_2 = [6, 26, 2] # Position [x, y, z] (m)\nposition_3 = [1, 0, 0] # Position [x, y, z] (m)\nposition_4 = [6, 1, 2] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors (Richtungsvektor) \n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den normierten Vektor aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\nvec1 = vectorcalculator(vector_1)\nvec2 = vectorcalculator(vector_2)\nvec3 = vectorcalculator(vector_3)\nvec4 = vectorcalculator(vector_4)\nprint(round(vectorcalculator.magnitude(vec1), 4))\nprint(vectorcalculator.norm(vec2))\nprint(vectorcalculator.multiplication(vec3, 3))\nprint(vectorcalculator.addition(vec2, vector_4))",
            "solution" : "mass_1 = 236124 # Masse in kg\nmass_2 = 339501 # Masse in kg\nmass_3 = 307900 # Masse in kg\nmass_4 = 306150 # Masse in kg\nposition_1 = [1, 5, 2] # Position [x, y, z] (m)\nposition_2 = [6, 26, 2] # Position [x, y, z] (m)\nposition_3 = [1, 0, 0] # Position [x, y, z] (m)\nposition_4 = [6, 1, 2] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors (Richtungsvektor)\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den Richtungsvektor eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Gibt die Kraft aus, die auf das Objekt wirkt'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt ein Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nobject_1 = gravitation(mass_1, position_1)\nobject_2 = gravitation(mass_2, position_2)\nobject_3 = gravitation(mass_3, position_3)\nobject_4 = gravitation(mass_4, position_4)\nobject_1.set_interactors([object_2, object_3, object_4])\nobject_2.set_interactors([object_1, object_3, object_4])\nobject_3.set_interactors([object_1, object_2, object_4])\nobject_4.set_interactors([object_1, object_2, object_3])\nforce_1 = [0, 0, 0]\nforce_2 = [0, 0, 0]\nforce_3 = [0, 0, 0]\nforce_4 = [0, 0, 0]\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "output" : "[0.0946, -0.2177, -0.0621]\n[-0.0046, -0.032, -0.0007]\n[0.1933, 0.2034, 0.1394]\n[-0.2833, 0.0463, -0.0766]"
          }, {
            "index" : 3,
            "description" : "Im letzten Programm mussten wir mühsam die interactors mit set_interactors definieren. Dies geht auch effizienter. Verbessere den Code des vorgerigen Programms um das Programm kürzer zu schreiben. Die Ausgabe soll wieder aus den Kräften, die auf die Objekte wirken, mit auf vier Stellen nach dem Komma gerundeten Zahlen bestehen.",
            "startingCode" : "mass_1 = 235232 # Masse in kg\nmass_2 = 362363 # Masse in kg\nmass_3 = 624653 # Masse in kg\nmass_4 = 773150 # Masse in kg\nposition_1 = [1, 6, 2] # Position [x, y, z] (m)\nposition_2 = [13, 26, 21] # Position [x, y, z] (m)\nposition_3 = [0, 0, 0] # Position [x, y, z] (m)\nposition_4 = [10, -1, -1] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors (Richtungsvektor)\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den Richtungsvektor eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nobject_1 = gravitation(mass_1, position_1)\nobject_2 = gravitation(mass_2, position_2)\nobject_3 = gravitation(mass_3, position_3)\nobject_4 = gravitation(mass_4, position_4)\nobject_1.set_interactors([object_2, object_3, object_4])\nobject_2.set_interactors([object_1, object_3, object_4])\nobject_3.set_interactors([object_1, object_2, object_4])\nobject_4.set_interactors([object_1, object_2, object_3])\nforce_1 = [0, 0, 0]\nforce_2 = [0, 0, 0]\nforce_3 = [0, 0, 0]\nforce_4 = [0, 0, 0]\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "solution" : "mass_1 = 235232 # Masse in kg\nmass_2 = 362363 # Masse in kg\nmass_3 = 624653 # Masse in kg\nmass_4 = 773150 # Masse in kg\nposition_1 = [1, 6, 2] # Position [x, y, z] (m)\nposition_2 = [13, 26, 21] # Position [x, y, z] (m)\nposition_3 = [0, 0, 0] # Position [x, y, z] (m)\nposition_4 = [10, -1, -1] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors (Richtungsvektor)\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den Richtungsvektor eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nobject_1 = gravitation(mass_1, position_1)\nobject_2 = gravitation(mass_2, position_2)\nobject_3 = gravitation(mass_3, position_3)\nobject_4 = gravitation(mass_4, position_4)\nsystem = [object_1, object_2, object_3, object_4]\nfor i in range(len(system)):\n\tinteractors = [object_1, object_2, object_3, object_4]\n\tdel interactors[i]\n\tsystem[i].set_interactors(interactors)\n\t\nforce_1 = [0, 0, 0]\nforce_2 = [0, 0, 0]\nforce_3 = [0, 0, 0]\nforce_4 = [0, 0, 0]\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "output" : "[0.0318, -0.2717, -0.0929]\n[-0.0081, -0.0245, -0.0205]\n[0.3546, 0.2013, 0.0503]\n[-0.3783, 0.0949, 0.0631]"
          }, {
            "index" : 4,
            "description" : "In der vorherigen Aufgabe haben wir lediglich die Kräfte berechnet, die auf ein Objekt wirken. Nun schauen wir uns eine Anwendung davon an. Wenn wir die Kraft auf ein Objekt kennen, dann können wir mit dem Zweiten Netownschen Gesetz (F = m * a) die Beschleunigung berechnen. Mit der Beschleunigung und einer Anfangsgeschwindigkeit könne wir also die Geschwindigkeit nach einem Zeitintervall (dt) berechnen. Ebenso können wir aus der Anfangsposition die Position nach dem Zeitintervall (dt) berechnen, indem wir die Geschwindikeit als Änderungsrate der Position nehmen. In dieser Aufgabe handelt es sich um eine Bewegung in nur einer Dimension. Gib in immer einer neuen Zeile die Geschwindigkeit und die Position in jedem Zeitintervall dt aus und lasse es bis t_max = 5 Sekunden laufen. Benütze dafür die vorgegebenen Konstanten und denke daran SI-Einheiten zu verwenden. Dies ist lediglich eine Einführunsaufgabe, die Verwendung einer Klasse ist nicht nötig.",
            "startingCode" : "dt = 0.1 # Zeitintervall (s)\n # Masse des betrachteten Objektes (kg)\nmass = 10\n# Kraft während den ersten drei Sekunden (N)\nforce_1 = 100\n# Kraft nach der dritten Sekunde (N)\nforce_2 = -150\n# Zeit, zu der abgebrochen werden soll (s)\nt_max = 5\n# Anfangsposition (m)\npos = 0\n# Anfangsgeschwindigkeit (m/s)\nvelocity = 0\n# Anfangszeit der Simulation\nt = 0",
            "solution" : "dt = 0.1 # Zeitintervall (s)\n # Masse des betrachteten Objektes (kg)\nmass = 10\n# Kraft während den ersten drei Sekunden (N)\nforce_1 = 100\n# Kraft nach der dritten Sekunde (N)\nforce_2 = -150\n# Zeit, zu der abgebrochen werden soll (s)\nt_max = 5\n# Anfangsposition (m)\npos = 0\n# Anfangsgeschwindigkeit (m/s)\nvelocity = 0\n# Anfangszeit der Simulation\nt = 0\nwhile t < t_max:\n\tif t < 3:\n\t\tvelocity += force_1 / mass * dt\n\t\tpos += velocity * dt\n\t\tprint(velocity)\n\t\tprint(pos)\n\telse:\n\t\tvelocity += force_2 / mass * dt\n\t\tpos += velocity * dt\n\t\tprint(velocity)\n\t\tprint(pos)\n\tt += dt",
            "output" : "1.0\n0.1\n2.0\n0.3\n3.0\n0.6\n4.0\n1.0\n5.0\n1.5\n6.0\n2.1\n7.0\n2.8\n8.0\n3.6\n9.0\n4.5\n10.0\n5.5\n11.0\n6.6\n12.0\n7.8\n13.0\n9.1\n14.0\n10.5\n15.0\n12.0\n16.0\n13.6\n17.0\n15.3\n18.0\n17.1\n19.0\n19.0\n20.0\n21.0\n21.0\n23.1\n22.0\n25.3\n23.0\n27.6\n24.0\n30.0\n25.0\n32.5\n26.0\n35.1\n27.0\n37.8\n28.0\n40.6\n29.0\n43.5\n30.0\n46.5\n28.5\n49.35\n27.0\n52.05\n25.5\n54.6\n24.0\n57.0\n22.5\n59.25\n21.0\n61.35\n19.5\n63.3\n18.0\n65.1\n16.5\n66.75\n15.0\n68.25\n13.5\n69.6\n12.0\n70.8\n10.5\n71.85\n9.0\n72.75\n7.5\n73.5\n6.0\n74.1\n4.5\n74.55\n3.0\n74.85\n1.5\n75.0\n0.0\n75.0\n-1.5\n74.85"
          }, {
            "index" : 5,
            "description" : "Jetzt wollen wir das neu Gelernte aus der letzten Aufgabe in das Programm aus der vorletzten Aufgabe einbauen. Nun gibt es auch ein reales Anwendungsbeispiel. Definiere eine Klasse, die allen vorgegebenen Planeten (von unserem Sonnensystem) mit den vorgegebenen Eigenschaften die auf sie wirkende Gravitationskraft berechnet und den Namen des Planeten, die Geschwindigkeit und die Position in jedem Zeitintervall dt in einer Zeile aus gibt (pro Planet eine Zeile mit einem Abstand zwischen jeder Eigenschaft und behalte die Rundungsfunktionen in der Klasse vectorcalculator bei).",
            "startingCode" : "class vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors (Richtungsvektor)\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den Richtungsvektor eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nAE = 149597870700 # Astronomische Einheit (m/AE)\n# Inputs für die Klasse:\ndt = 10000 # Zeitintervall (s)\n# gravitation(Name (string), Masse (kg),\n# Position [x, z, z] (m), Geschwindigkeit [x, y, z] (m/s)\nsun = gravitation('Sonne', 1.989e30,\n  [0, 0, 0], [0, 0, 0])\nmerkur = gravitation('Merkur', 3.301e23, 4897400,\n  [0.387099 * AE, 0, 0], [0, 47360, 0])\nvenus = gravitation('Venus', 4.8675e24,\n  [0.723 * AE, 0, 0], [0, 35020, 0])\nearth = gravitation('Erde', 5.972e24,\n  [1 * AE, 0, 0], [0, 29780, 0])\nmars = gravitation('Mars', 6.419e23,\n  [1.524 * AE, 0, 0], [0, 24130, 0])\njupiter = gravitation('Jupiter', 1.899e27,\n  [5.203 * AE, 0, 0], [0, 13070, 0])\nsaturn = gravitation('Saturn', 5.685e26,\n  [9.5826  * AE, 0, 0], [0, 9690, 0])\nuranus = graviation('Uranus', 8.683e25,\n  [19.201 * AE, 0, 0], [0, 6810, 0])\nneptun = gravitation('Neptun', 1.0243e26,\n  [30.07 * AE, 0, 0], [0, 5430, 0])\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "solution" : "class vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung des normierten Vektors (Richtungsvektor)\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt den Richtungsvektor eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\tupdate()\n\t\tDie Geschwindigkeit und die Position nach dt\n\t'''\n\tdef __init__(self, name, mass, position, velocity):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.name = name\n\t\tself.mass = mass\n\t\tself.position = position\n\t\tself.velocity = velocity\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\tvectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\n\tdef update(self):\n\t\t'''Veraendert die Geschwindigkeit und\n\t\tdie Position und gibt diese aus'''\n\t\tself.velocity = vectorcalculator.addition(\n\t\t  vectorcalculator(self.velocity),\n\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(gravitation.force(self))\n\t\t  , 1 / self.mass)), dt))\n\t\tself.position = vectorcalculator.addition(\n\t\t  vectorcalculator(self.position),\n\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t  self.velocity), dt))\n\t\tprint(self.name + ' ' + str(self.position) + ' ' +\n\t\t  str(self.velocity))\nAE = 149597870700 # Astronomische Einheit (m/AE)\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\n# Inputs für die Klasse:\n# gravitation(Name (string), Masse (kg),\ndt = 10000 # Zeitintervall (s)\n# Position [x, z, z] (m), Geschwindigkeit [x, y, z] (m/s)\nsun = gravitation('Sonne', 1.989e30,\n  [0, 0, 0], [0, 0, 0])\nmerkur = gravitation('Merkur', 3.301e23,\n  [0.387099 * AE, 0, 0], [0, 47360, 0])\nvenus = gravitation('Venus', 4.8675e24,\n  [0.723 * AE, 0, 0], [0, 35020, 0])\nearth = gravitation('Erde', 5.972e24,\n  [1 * AE, 0, 0], [0, 29780, 0])\nmars = gravitation('Mars', 6.419e23,\n  [1.524 * AE, 0, 0], [0, 24130, 0])\njupiter = gravitation('Jupiter', 1.899e27,\n  [5.203 * AE, 0, 0], [0, 13070, 0])\nsaturn = gravitation('Saturn', 5.685e26,\n  [9.5826  * AE, 0, 0], [0, 9690, 0])\nuranus = gravitation('Uranus', 8.683e25,\n  [19.201 * AE, 0, 0], [0, 6810, 0])\nneptun = gravitation('Neptun', 1.0243e26,\n  [30.07 * AE, 0, 0], [0, 5430, 0])\nsystem = [sun, merkur, venus, earth, mars, jupiter, saturn,\n  uranus, neptun]\nfor i in range(len(system)):\n\tinteractors = [sun, merkur, venus, earth, mars, jupiter,\n  saturn, uranus, neptun]\n\tdel interactors[i]\n\tsystem[i].set_interactors(interactors)\nfor i in range(0, 10 * dt, dt):\n\tfor i in range(len(system)):\n\t\tsystem[i].update()",
            "output" : "Sonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57905226150.1, 473600000.0, 0.0] [-396.0, 47360.0, 0.0]\nVenus [108158130516.0, 350200000.0, 0.0] [-113.0, 35020.0, 0.0]\nErde [149597280700.0, 297800000.0, 0.0] [-59.0, 29780.0, 0.0]\nMars [227986894947.0, 241300000.0, 0.0] [-26.0, 24130.0, 0.0]\nJupiter [778357701252.0, 130700000.0, 0.0] [-2.0, 13070.0, 0.0]\nSaturn [1.43353654577e+12, 96900000.0, 0.0] [-1.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 68100000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 54300000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57897306150.1, 947170000.0, 0.0] [-792.0, 47357.0, 0.0]\nVenus [108155870516.0, 700400000.0, 0.0] [-226.0, 35020.0, 0.0]\nErde [149596100700.0, 595600000.0, 0.0] [-118.0, 29780.0, 0.0]\nMars [227986374947.0, 482600000.0, 0.0] [-52.0, 24130.0, 0.0]\nJupiter [778357661252.0, 261400000.0, 0.0] [-4.0, 13070.0, 0.0]\nSaturn [1.43353652577e+12, 193800000.0, 0.0] [-2.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 136200000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 108600000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57885426150.1, 1420680000.0, 0.0] [-1188.0, 47351.0, 0.0]\nVenus [108152480516.0, 1050590000.0, 0.0] [-339.0, 35019.0, 0.0]\nErde [149594330700.0, 893400000.0, 0.0] [-177.0, 29780.0, 0.0]\nMars [227985594947.0, 723900000.0, 0.0] [-78.0, 24130.0, 0.0]\nJupiter [778357601252.0, 392100000.0, 0.0] [-6.0, 13070.0, 0.0]\nSaturn [1.43353649577e+12, 290700000.0, 0.0] [-3.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 204300000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 162900000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57869586150.1, 1894090000.0, 0.0] [-1584.0, 47341.0, 0.0]\nVenus [108147960516.0, 1400770000.0, 0.0] [-452.0, 35018.0, 0.0]\nErde [149591970700.0, 1191200000.0, 0.0] [-236.0, 29780.0, 0.0]\nMars [227984554947.0, 965200000.0, 0.0] [-104.0, 24130.0, 0.0]\nJupiter [778357521252.0, 522800000.0, 0.0] [-8.0, 13070.0, 0.0]\nSaturn [1.43353645577e+12, 387600000.0, 0.0] [-4.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 272400000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 217200000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57849786150.1, 2367370000.0, 0.0] [-1980.0, 47328.0, 0.0]\nVenus [108142310516.0, 1750940000.0, 0.0] [-565.0, 35017.0, 0.0]\nErde [149589020700.0, 1489000000.0, 0.0] [-295.0, 29780.0, 0.0]\nMars [227983254947.0, 1206500000.0, 0.0] [-130.0, 24130.0, 0.0]\nJupiter [778357421252.0, 653500000.0, 0.0] [-10.0, 13070.0, 0.0]\nSaturn [1.43353640577e+12, 484500000.0, 0.0] [-5.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 340500000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 271500000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57826026150.1, 2840490000.0, 0.0] [-2376.0, 47312.0, 0.0]\nVenus [108135530516.0, 2101090000.0, 0.0] [-678.0, 35015.0, 0.0]\nErde [149585480700.0, 1786790000.0, 0.0] [-354.0, 29779.0, 0.0]\nMars [227981694947.0, 1447800000.0, 0.0] [-156.0, 24130.0, 0.0]\nJupiter [778357301252.0, 784200000.0, 0.0] [-12.0, 13070.0, 0.0]\nSaturn [1.43353634577e+12, 581400000.0, 0.0] [-6.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 408600000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 325800000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57798306150.1, 3313420000.0, 0.0] [-2772.0, 47293.0, 0.0]\nVenus [108127620516.0, 2451220000.0, 0.0] [-791.0, 35013.0, 0.0]\nErde [149581350700.0, 2084570000.0, 0.0] [-413.0, 29778.0, 0.0]\nMars [227979874947.0, 1689100000.0, 0.0] [-182.0, 24130.0, 0.0]\nJupiter [778357161252.0, 914900000.0, 0.0] [-14.0, 13070.0, 0.0]\nSaturn [1.43353627577e+12, 678300000.0, 0.0] [-7.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 476700000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 380100000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57766636150.1, 3786120000.0, 0.0] [-3167.0, 47270.0, 0.0]\nVenus [108118580516.0, 2801320000.0, 0.0] [-904.0, 35010.0, 0.0]\nErde [149576630700.0, 2382340000.0, 0.0] [-472.0, 29777.0, 0.0]\nMars [227977794947.0, 1930400000.0, 0.0] [-208.0, 24130.0, 0.0]\nJupiter [778357001252.0, 1045600000.0, 0.0] [-16.0, 13070.0, 0.0]\nSaturn [1.43353619577e+12, 775200000.0, 0.0] [-8.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 544800000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 434400000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57731016150.1, 4258560000.0, 0.0] [-3562.0, 47244.0, 0.0]\nVenus [108108410516.0, 3151390000.0, 0.0] [-1017.0, 35007.0, 0.0]\nErde [149571320700.0, 2680100000.0, 0.0] [-531.0, 29776.0, 0.0]\nMars [227975454947.0, 2171700000.0, 0.0] [-234.0, 24130.0, 0.0]\nJupiter [778356821252.0, 1176300000.0, 0.0] [-18.0, 13070.0, 0.0]\nSaturn [1.43353610577e+12, 872100000.0, 0.0] [-9.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 612900000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 488700000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57691446150.1, 4730710000.0, 0.0] [-3957.0, 47215.0, 0.0]\nVenus [108097110516.0, 3501430000.0, 0.0] [-1130.0, 35004.0, 0.0]\nErde [149565420700.0, 2977850000.0, 0.0] [-590.0, 29775.0, 0.0]\nMars [227972854947.0, 2413000000.0, 0.0] [-260.0, 24130.0, 0.0]\nJupiter [778356621252.0, 1307000000.0, 0.0] [-20.0, 13070.0, 0.0]\nSaturn [1.43353600577e+12, 969000000.0, 0.0] [-10.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 681000000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 543000000.0, 0.0] [0.0, 5430.0, 0.0]"
          }]
      }
    ]
}
