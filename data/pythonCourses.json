{
  "exercises" : [{
      "index" : 0,
      "title" : "Freies Coden",
      "description" : "Dies ist keine Aufgabe. Hier kannst du so viel und frei coden, wie du willst.\nProbier hier doch einige neu gelernte Konzepte aus!\n\nHalte deinen Mauszeiger über den Titel der Aufgabe <b>(Freies Coden)</b>, um alle möglichen Kurse zu sehen.\n\nViel Spass!",
      "subexercises" : []
    }, {
      "index" : 1,
      "title" : "Grundlagen im Rechnen mit Variablen",
      "description" : "In diesem Kapitel befassen wir uns damit Variablen zu definieren und auszugeben. Variable wird in Python mit x = 3 definiert und mit print(x) ausgegeben. Dabei ist x die Variable, an dessen Stelle ein beliebiges Zeichen stehen könnte, die dem Wert 3 zugeordnet wird. Die Ausgabe print(x) gibt dabei den Wert der Variable x aus. Jeder Befehl, der dem Programm gegeben wird steht dabei in einer neuen Zeile. Im Code sieht dies folgendermassen aus.<code class=\"python\">x = 3\nprint(x)</code>",
      "subexercises" : [{
          "index" : 0,
          "description" : "Definiere eine Variable a mit dem Wert 7 und gib diese aus.",
          "startingCode" : "",
          "solution" : "a = 7\nprint(a)",
          "output" : "7"
          }, {
          "index" : 1,
          "description" : "Mit a = a + n wird eine Zahl n zu der Variable a addiert, wobei n also eine beliebige Zahl sein kann und a mit dem Wert a + n neu definiert wird. Definiere eine Varbable c mit dem Wert 3. Addiere danach 4 und gibt den Wert der Varbiable aus.",
          "startingCode" : "",
          "solution" : "a = 3\na = a + 4\nprint(a)",
          "output" : "7"   
          }, {
          "index" : 2,
          "description" : "Die Addition einer Zahl zu einer Variable a kann auch abgekürzt mit a += n geschrieben werden. Dies hat dabei die gleiche Bedeutung wie a = a + n. Definiere nun eine Variable q mit dem Wert 5, addiere in einem ersten Schritt 18, gib das Zwischenresultat aus und addiere dazu in einem zweiten Schritt 1053 und gib q aus.",
          "startingCode" : "",
          "solution" : "q = 5\nq += 18\nprint(q)\nq += 1053\nprint(q)",
          "output" : "23\n1076"   
          }, {
          "index" : 3,
          "description" : "Wie für die Addition einer Zahl zu einer Variable a kann auch eine Multiplikation einer Zahl mit einer Variable mit a *= n geschrieben werden. Definiere nun eine Variable b mit dem Wert 23 und multipliziere diese mit 14. Gib das Resultat aus.",
          "startingCode" : "",
          "solution" : "b = 23\nb *= 14\nprint(b)",
          "output" : "322"   
          }, {
          "index" : 4,
          "description" : "Definiere eine Variable z mit dem Wert 5, addiere 7, multipliziere sie mit 9 und addiere 4. Gib jeweils die Zwischenresultate und das Endresultat aus.",
          "startingCode" : "",
          "solution" : "z = 5\nz += 7\nprint(z)\nz *= 9\nprint(z)\nz += 4\nprint(z)",
          "output" : "12\n108\n112"   
          }, {
          "index" : 5,
          "description" : "Mit a ** b kann eine Variable a hoch eine Variable b gerechnet werden. Definiere eine Variable c mit dem Wert 25 und eine Variable e mit dem Wert 24. Addiere 5 zu c und rechne danach c hoch e und gib das Resultat aus.",
          "startingCode" : "",
          "solution" : "c = 25\ne = 24\nc += 5\nc = c ** e\nprint(c)",
          "output" : "282429536481000000000000000000000000"   
          }, {
          "index" : 6,
          "description" : "Einer Variable kann nicht nur ein Wert zugeorndet werden, sondern auch ein Text. Dieses Datenformat wird dann als String bezeichnet. Der Text kann einer Variable wie folgt definiert und ausgegeben. <code class=\"python\">x = 'String'\nprint(x)</code>Definiere eine Variable text mit dem String von 'Dies ist ein kleiner Text' und gib diese aus.",
          "startingCode" : "",
          "solution" : "wert = 'Dies ist ein kleiner Text'\nprint(wert)",
          "output" : "Dies ist ein kleiner Text"   
          }, {
          "index" : 7,
          "description" : "Definiere eine Variable wetter mit dem String 'Heute ist ein schoener Tag' und gib diese aus.",
          "startingCode" : "",
          "solution" : "wetter = 'Heute ist ein schoener Tag'\nprint(wetter)",
          "output" : "Heute ist ein schoener Tag"   
          }, {
          "index" : 8,
          "description" : "Nun können wir auch zwei Datenformate gleichzeitig ausgeben. Dabei werden die Variablen in der Ausgabe durch Kommata voneinander getrennt. Definiere eine Variable temperatur mit dem Wert 30 und eine Variable wetter mit dem String 'Es ist warmes Wetter' und gib diese in einer Zeile aus.",
          "startingCode" : "",
          "solution" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\nprint(temperatur, wetter)",
          "output" : "(30, 'Es ist warmes Wetter')"
          }, {
          "index" : 9,
          "description" : "Bei der letzten Aufgabe haben wir gemerkt, dass die Ausgabe mit Klammern und Kommata versehen war, die wir nicht wollen. Man kann mit Python Ausgaben machen, die nur für Strings funktionieren, weshalb wir die nachfolgende Variable y, der ein Integer zugeordnet ist zuerst in einen String umwandeln müssen.<code class=\"python\">x = 'String'\ny = 20\ny = str(y)\nprint(x + y)</code>Verändere nun das Programm aus der letzten Aufgabe, sodass der Output keine Kommata oder Klammern enthält.",
          "startingCode" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\nprint(temperatur, wetter)",
          "solution" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\ntemperatur = str(temperatur)\nprint(temperatur + wetter)",
          "output" : "30Es ist warmes Wetter"
          }, {
          "index" : 10,
          "description" : "Das Problem mit der Ausgabe der letzten Aufgabe war, dass wir mit der Ausgabe der Strings keinen Leerschlag zweischen der Nummer und der Beschreibung haben. Verändere nun den Code der letzten Aufgabe um einen Leerschlag zwischen der Nummer und der Beschreibung zu erhalten.",
          "startingCode" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\ntemperatur = str(temperatur)\nprint(temperatur + wetter)",
          "solution" : "temperatur = 30\nwetter = 'Es ist warmes Wetter'\ntemperatur = str(temperatur)\nprint(temperatur + ' ' + wetter)",
          "output" : "30 Es ist warmes Wetter"
          }, {
          "index" : 11,
          "description" : "Benutze nun die vorher gelernten Tools um das Ausgabenformat zu verbessern und schreibe ein Programm, in dem eine Variable windgeschwindigkeit mit dem Wert 120 definiert wird und zweite Variable warnung mit dem String 'Es gibt einen Sturm'. Diese beiden Variablen sollen nun auf einer Zeile ausgegeben werden.",
          "startingCode" : "",
          "solution" : "windgeschwindigkeit = 120\nwarnung = 'Es gibt einen Sturm'\nwindgeschwindigkeit = str(windgeschwindigkeit)\nprint(windgeschwindigkeit + ' ' + warnung)",
          "output" : "120 Es gibt einen Sturm"
          }]
    }, {
      "index" : 2,
      "title" : "If-else-Verzweigungen",
      "description" : "Da wir gelernt haben wie wir Variablen definieren und ausgeben können, können wir zum nächsten Kapitel überschreiten, welches die erste Möglichkeit ist die Variablen zu verarbeiten. Dieses Kapitel befasst sich mit if-else-Verzweigungen. Eine if-Verzweigung ist besteht aus einer Bedingung und einem ausführenden Teil. Es ist also ein wenn es so ist, dann macht das Programm es so und wenn nicht, dann macht es das, was bei else steht. Dabei wird die if-Verzweigung nur einmal durchlaufen. If-else-Verzweigungen werden folgendermassen definiert: <code class=\"python\">if x == 1:\n\tx += 1\nelif x == 2\n\tx = 3\nelse:\n\tx = 0</code>Dabei wird wenn x = 1 ist x = 2, wenn x = 2 ist x = 3 und andernfalls x = 0 ausgegeben. Dabei muss darauf geachtet werden, dass beim Abfragen des Wertes eine Variable die Notation x == n verwendet werden muss, da x = n einer Zuordnung des Wertes n entsprechen würde.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Erstelle ein Programm, in dem eine Variable a mit dem Wert 90 definiert wird, teste mit einer If-else-Verzweigung, ob der Variable der Wert 90 zugeordnet ist oder nicht und gibt das Resultat im vorgegebenen Format aus.",
          "startingCode" : "print(str(a) + ' ' + 'ist der Wert 90 zugeordnet')\nprint(str(a) + ' ' + 'ist nicht der Wert 90 zugeordnet')",
          "solution" : "a = 90\nif a == 90:\n\tprint(str(a) + ' ' + 'ist der Wert 90 zugeordnet')\nelse:\n\tprint(str(a) + ' ' + 'ist nicht der Wert 90 zugeordnet')",
          "output" : "90 ist der Wert 90 zugeordnet"
          }, {
          "index" : 1,
          "description" : "Modifiziere die if-else-Verzweigung so, dass das Programm im vorgegebenen Format ausgibt, ob x grösser, gleich oder kleiner als 9 ist.",
          "startingCode" : "x = 9\nif x < 9:\n\tprint('x ist groesser als 9')\nelif x = 13:\n\tprint('x ist gleich 9')\n\n\tprint('x ist kleiner als 9')",
          "solution" : "x = 9\nif x > 9:\n\tprint('x ist groesser als 9')\nelif x == 9:\n\tprint('x ist gleich 9')\nelse:\n\tprint('x ist kleiner als 9')",
          "output" : "x ist gleich 9"
          }, {
          "index" : 2,
          "description" : "Erstelle ein Programm, das die zwei vorgegebenen Variablen x und y vergleicht und das Ergebnis im vorgegebenen Format ausgibt.",
          "startingCode" : "x = 5\ny = 7\nprint('x ist groesser als y')\nprint('x ist gleich y')\nprint('x ist kleiner als y')",
          "solution" : "x = 5\ny = 7\nif x > y:\n\tprint('x ist groesser als y')\nelif x == y:\n\tprint('x ist gleich y')\nelse:\n\tprint('x ist kleiner als y')",
          "output" : "x ist kleiner als y"   
          }, {
          "index" : 3,
          "description" : "Erweitere das Programm aus der letzten Aufgabe nun um ein Programm zu estellen, das x mit den beiden vorgegebenen Variablen y und z vergleicht.",
          "startingCode" : "x = 9\ny = 13\nz = 9\nif x > y:\n\tprint('x ist groesser als y und z')\nelif x == y:\n\tprint('x ist gleich y und groesser als z')\nelse:\n\tprint('x ist kleiner als y und gleich z')",
          "solution" : "x = 9\ny = 13\nz = 9\nif x > y:\n\tif x > z:\n\t\tprint('x ist groesser als y und z')\n\telif x == z:\n\t\tprint('x ist groesser als y und gleich z')\n\telse:\n\t\tprint('x ist groesser als y und kleiner als z')\nelif x == y:\n\tif x > z:\n\t\tprint('x ist gleich y und groesser als z')\n\telif x == z:\n\t\tprint('x ist gleich y und z')\n\telse:\n\t\tprint('x ist gleich y und kleiner als z')\nelse:\n\tif x > z:\n\t\tprint('x ist kleiner als y und groesser als z')\n\telif x == z:\n\t\tprint('x ist kleiner als y und gleich z')\n\telse:\n\t\tprint('x ist kleiner als y und z')",
          "output" : "x ist kleiner als y und gleich z"   
          }, {
          "index" : 4,
          "description" : "Erstelle ein Programm, dass eine Variable x mit dem Wert 13 definiert und danach testet, ob es sich beim Wert dieser Variable um einen String oder um einen Integer handelt. Verwende dafür die in Python vordefinierten Funktionen str(x) und int(x), wobei x die Variable, deren Datentyp getestet werden soll. Gib das Resultat im vorgegebenen Format aus.",
          "startingCode" : "print(str(x) + ' ' + 'ist ein Integer')\nprint(str(x) + ' ' + 'ist ein String')",
          "solution" : "x = 13\nif x == int(x):\n\tprint(str(x) + ' ' + 'ist ein Integer')\nif x == str(x):\n\tprint(str(x) + ' ' + 'ist ein String')",
          "output" : "13 ist ein Integer"
          }, {
          "index" : 5,
          "description" : "Erstelle ein Programm, welches den Datentyp der vorgegebenen Variablen x, y und z herausfinden kann und das Ergebnis im vorgegebenen Format ausgibt.",
          "startingCode" : "x = '14'\ny = 41\nz = 123.5\nprint('ist ein Integer')\nprint('ist ein String')\nprint('ist weder ein Integer, noch ein String')",
          "solution" : "x = '14'\ny = 41\nz = 123.5\nif x == int(x):\n\tprint(str(x) + ' ' + 'ist ein Integer')\nelif x == str(x):\n\tprint(str(x) + ' ' + 'ist ein String')\nelse:\n\tprint(str(x) + ' ' + 'ist weder ein Integer, noch ein String')\nif y == int(y):\n\tprint(str(y) + ' ' + 'ist ein Integer')\nelif y == str(y):\n\tprint(str(y) + ' ' + 'ist ein String')\nelse:\n\tprint(str(y) + ' ' + 'ist weder ein Integer, noch ein String')\nif z == int(z):\n\tprint(str(z) + ' ' + 'ist ein Integer')\nelif z == str(z):\n\tprint(str(z) + 'ist ein String')\nelse:\n\tprint(str(z) + ' ' + 'ist weder ein Integer, noch ein String')",
          "output" : "14 ist ein String\n41 ist ein Integer\n123.5 ist weder ein Integer, noch ein String"
          }, {
          "index" : 6,
          "description" : "In der letzten Aufgabe haben wir herausgefunden, dass es auch noch andere Datentyps gibt als nur String und Integer. 123.5 war in diesem Beispiel eine sogenannte Floating Point Zahl. Eine Floating Point Zahl n kann mit int(n) in einen Integer umgewandelt werden. Teste für jede der vorgegebenen Variablen, ob ihnen eine Floating Point Point Zahl zugeordnet ist und gib diese, falls es eine Floating Point Zahl ist im vorgegebenen Format aus. Benutze dafür den Befehl float(n) um eine Zahl beliebigen Datentypes in eine Floating Point Zahl umzuwandeln.",
          "startingCode" : "a = '112'\nb = 4.3623115\nc = 123.0\nd = 124\nprint(str(a) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(a))\nprint(str(b) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(b))\nprint(str(c) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(c))\nprint(str(d) + ' ' + 'ist eine Floating Point Zahl mit dem Integer Wert von' + ' ' + str(int(d))",
          "solution" : "a = '112.235'\nb = 4.3623115\nc = 123.0\nd = 124\nif a == float(a):\n\tprint(str(a) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(a)))\nif b == float(b):\n\tprint(str(b) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(b)))\nif c == float(c):\n\tprint(str(c) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(c)))\nif d == float(d):\n\tprint(str(d) + ' ' +\n\t  'ist eine Floating Point Zahl mit dem Integer Wert von'\n\t  + ' ' + str(int(d)))",
          "output" : "4.3623115 ist eine Floating Point Zahl mit dem Integer Wert von 4\n123.0 ist eine Floating Point Zahl mit dem Integer Wert von 123\n124 ist eine Floating Point Zahl mit dem Integer Wert von 124"
          }]
    }, {
      "index" : 3,
      "title" : "While-Schlaufen",
      "description" : "Dieses Kapitel befasst sich mit den sogenannten While-Schlaufen. Eine While-Schlaufe in Python sieht beispielsweise folgendermassen aus: <code class=\"python\">while x < 2:\n\tx += 1</code>Hierbei deklariert das Keyword while, dass eine While-Schlaufe folgt. Nach dem Keyword steht die sogenannte Condition. Sie wird vor jeder Durchführung des Code-Blocks geprüft. Falls diese Condition nicht (mehr) zutrifft, wird die Schlaufe abgebrochen. Ansonsten wird der folgende Codeblock ausgeführt.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Modifiziere die Schlaufe so, dass alle ganzen Zahlen von 0 bis und mit 4 ausgegeben werden.",
          "startingCode" : "x = 0\nwhile x < :\n\tprint(x)\n\tx += 1",
          "solution" : "x = 0\nwhile x < 5:\n\tprint(x)\n\tx += 1",
          "output" : "0\n1\n2\n3\n4"
          }, {
            "index" : 1,
            "description" : "Gib ein rechtwinkliges Dreieck bestehend aus Sternen (*) aus, welches aus vier Schichten besteht und dessen jede Schicht immer um einen Stern breiter ist als die Letzte. Die erste Schicht besteht somit aus einem Stern, während die Letzte aus vier besteht.",
            "startingCode" : "x = 1\nwhile x < :\n\tprint()\n\tx += 1",
            "solution" : "x = 1\nwhile x < 5:\n\tprint(x * '*')\n\tx += 1",
            "output" : "*\n**\n***\n****"
          }, {
            "index" : 2,
            "description" : "Erstelle nun selbst eine While-Schleife, die die Zahlen von 3 bis und mit 9 und je einer Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "x = 3\nwhile x < 10:\n\tprint(x)\n\tx += 1",
            "output" : "3\n4\n5\n6\n7\n8\n9"
          }, {
            "index" : 3,
            "description" : "While-Schlaufen können auch mit Variablen des Datentyps Boolean erstellt werden. Ein Boolean hat zwei mögliche Werte, True oder False. Diese Zuordnungen müssen dabei genau so geschrieben werden. Der Boolean stellt also nun die Bedingung dar, die vorher beispielsweise durch x < 5 dargestellt wurde. Modifiziere die Schleife nun so, dass sechs mal in je einer Zeile die Ziffer 7 ausgegeben wird.",
            "startingCode" : "x = 0\nwhile :if x < 7:\n\t\tprint(7)\n\t\tx += 1\n\telse:",
            "solution" : "printing = True\nx = 0\nwhile printing:\n\tif x < 7:\n\t\tprint(7)\n\t\tx += 1\n\telse:\n\t\tprinting = False",
            "output" : "7\n7\n7\n7\n7\n7\n7"
          }, {
            "index" : 4,
            "description" : "Das Zeichen a % b führt die sogenannte Modulo Operation durch. Dabei wird der Rest einer Division von a durch b in den natürlichen Zahlen durchgeführt. Benutze in dieser Aufgabe einen Boolean und die Modulo Operation um eine While-Schlaufe zu erstellen, die alle durch 7 Teilbaren Zahlen von 13 bis 136 in je einer Zeile ausgibt.",
            "startingCode" : "",
            "solution" : "a = True\nstart = 13\nwhile a:\n\tif start < 136:\n\t\tif start % 7 == 0:\n\t\t\tprint(start)\n\t\tstart += 1\n\telse:\n\t\ta = False",
            "output" : "14\n21\n28\n35\n42\n49\n56\n63\n70\n77\n84\n91\n98\n105\n112\n119\n126\n133"
          }]
      }, {
      "index" : 4,
      "title" : "Listen",
      "description" : "Dieses Kapitel befasst sich mit Listen. Eine Liste ist eine Sammlung von Elementen, die geordnet sind. Zu jedem Element ist ein Index zugeordnet, der bei 0 startet und in einer Schritten hoch zählt. Für die Listen gibt es verschiedene Operationen, die Sie in diesem Kapitel kennenlernen werden. Eine Liste wird mit eckigen Klammern gekennzeichnet und die Elemente werden mit Kommata getrennt: <code class=\"python\">a = ['Element 1', 'Element 2']</code>Ein Element aus einer Liste kann herausgegeben werden, indem die Liste und das der Index des Elementes in eckigen Klammern geschrieben wird: <code class=\"python\">a[0]</code>",
      "subexercises" : [{
          "index" : 0,
          "description" : "Schreibe ein Programm, dass eine Liste mit der Zahlen 1 bis und mit 10 erstellt und diese Ausgibt.",
          "startingCode" : "",
          "solution" : "a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nprint(a)",
          "output" : "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]"
          }, {
            "index" : 1,
            "description" : "Mit a.append(Element) wird ein Element ans Ende einer Liste angehängt. Erstelle nun eine Signum Funktion mit If-else-Verzweigungen und einer While-Schleife, die auf die vorgegebene Liste angewendet wird und die Lösung ausgiebt ausgiebt.",
            "startingCode" : "a = [1, 1, -1, -1, 1, 1, -1, 0, 1, -1, 0]\nb = [] ",
            "solution" : "x = 0\na = [2, 5, -2, -8, 4, 100, -12, 0, 1, -4, 0]\nb = []\nwhile x < len(a):\n\tif a[x] > 0:\n\t\tb.append(1)\n\telif a[x] == 0:\n\t\tb.append(0)\n\telse:\n\t\tb.append(-1)\n\tx += 1\nprint(b) ",
            "output" : "[1, 1, -1, -1, 1, 1, -1, 0, 1, -1, 0]" 
          }, {
            "index" : 2,
            "description" : "Schreibe ein Programm, mit dem das vierte, das siebte und das achte Element der vorgegebenen Liste b in je einer Zeile ausgegeben wird",
            "startingCode" : "b = [1, 25, -12, -561, 1435, 'asdf', -321,'41', 63, 0]",
            "solution" : "b = [1, 25, -12, -561, 1435, 'asdf', -321,'41', 63, 0]\n# Das 4. Element hat den Index 3, da dieser bei 0 anfängt\nprint(b[3])\nprint(b[6])\nprint(b[7])",
            "output" : "-561\n-321\n41" 
          }, {
            "index" : 3,
            "description" : "In Python können auch zwei Listen addiert werden. Wenn a und b zwei Listen sind, dann ergibt die Rechnung c = a + b eine neue Liste c, welche am Anfang die Elemente der Liste a enthält und am Ende die Elemente der Liste b. Gib die Liste aus, die entstehen wird wenn die vorgegebenen Listen a und b addiert werden. Gib in der nächsten Zeile das Ergebnis der Addition von b und a aus.",
            "startingCode" : "a = [1, 6, 2, 8, 7]\nb = [8, 37, 943, 23]",
            "solution" : "a = [1, 6, 2, 8, 7]\nb = [8, 37, 943, 23]\nc = a + b\nprint(c)\nc = b + a\nprint(c)",
            "output" : "[1, 6, 2, 8, 7, 8, 37, 943, 23]\n[8, 37, 943, 23, 1, 6, 2, 8, 7]" 
          }, {
            "index" : 4,
            "description" : "Der + Operator sollte jedoch nicht benutzt werden um zwei Listen aneinander zu hängen, da dieser sehr ineffizient arbeitet. Es ist besser für ein einzelnes Element den Operator a.append(n) zu benutzen. Schreibe ein Programm, das die vorgegebenen Listen q und w mithilfe des append() Operators aneinanderhängt und gib die entstandene Liste aus.",
            "startingCode" : "q = [2, 72, 457, 37, 2]\nw = [3, 7, 26, 48, 1]",
            "solution" : "q = [2, 72, 457, 37, 2]\nw = [3, 7, 26, 48, 1]\nq.append(w)print(q)",
            "output" : "[2, 72, 457, 37, 2, [3, 7, 26, 48, 1]]"
          }, {
            "index" : 5,
            "description" : "In der letzten Aufgabe haben wir zwar ein Ergebnis erhalten, jedoch nicht das nicht in der Form, wie wir es mit dem q = q + w erhalten würden. Dieses können wir erhalten, indem wir a.extend(b) benutzen, welcher die Elemente von b am Ende der Liste a einfügt. Füge die Elemente der Liste a am Ende der Liste b ein und gib die bearbeitete Liste b aus.",
            "startingCode" : "a = [3, 73, 48, 3]\nb = [47, 36]",
            "solution" : "a = [3, 73, 48, 3]\nb = [47, 36]\nb.extend(a)\nprint(b)",
            "output" : "[47, 36, 3, 73, 48, 3]"
          }, {
            "index" : 6,
            "description" : "Benutze eine While-Schlaufe um jedes Element einer Liste, die aus den beiden vorgegebenen Listen x und y besteht zu halbieren und gib die entstehende Liste aus.",
            "startingCode" : "x = [37, 83, 22, 37, 48]\ny = [10, 20, 24]",
            "solution" : "x = [37, 83, 22, 37, 48]\ny = [10, 20, 24]\nz = x + y\na = 0\nwhile a < len(z):\n\tz[a] = float(z[a]) / 2\n\ta += 1\nprint(z)",
            "output" : "[18.5, 41.5, 11.0, 18.5, 24.0, 5.0, 10.0, 12.0]" 
          }, {
            "index" : 7,
            "description" : "Schreibe ein Programm, das alle Zahlen in der Liste a, die grösser als 100 sind durch zwei teilt und gib die damit erstellte Liste aus.",
            "startingCode" : "a = [1602, 4, -1005, 125, 36, 72, 252]",
            "solution" : "a = [1602, 4, -1005, 125, 36, 72, 252]\nx = 0\nwhile x < len(a):\n\tif a[x] > 100:\n\t\ta[x] = float(a[x]) / 2\n\tx += 1\nprint(a)",
            "output" : "[801.0, 4, -1005, 62.5, 36, 72, 126.0]" 
          }, {
            "index" : 8,
            "description" : "Schreibe ein Programm, das in jeder Zeile eine Liste ausgibt, die in der ersten Zeile das Element 0 enthält, in der zweiten Zeile das Element 0 und das Element 2, und der dritten Zeile das Element 0, das Element 2 und das Element 4. Dieses Muster soll fortgesetzt werden bis zur Liste mit allen geraden Zahlen von 0 bis und mit 16.",
            "startingCode" : "",
            "solution" : "x = 0\na = []\nwhile x <= 16:\n\ta.append(x)\n\tprint(a)\n\tx += 2",
            "output" : "[0]\n[0, 2]\n[0, 2, 4]\n[0, 2, 4, 6]\n[0, 2, 4, 6, 8]\n[0, 2, 4, 6, 8, 10]\n[0, 2, 4, 6, 8, 10, 12]\n[0, 2, 4, 6, 8, 10, 12, 14]\n[0, 2, 4, 6, 8, 10, 12, 14, 16]" 
          }, {
            "index" : 9,
            "description" : "Schreibe ein Programm, das die vorgegebene Liste a in zwei Listen aufspaltet, wobei die erste Liste alle negativen Elemente von a enthalten soll und die zweite alle positiven Elemente von a enthalten soll. Die Zahl 0 soll weder in die Liste mit den positiven Zahlen, noch in die Liste mit den negativen Zahlen. Die Ordnung der Elemente soll dabei unverändert bleiben. Gib diese zwei entstandenen Listen in je einer Zeile aus.",
            "startingCode" : "a = [-136, 2347, -478, 0, 47, 8, 0, 13, -26, 5, -58, -3]",
            "solution" : "a = [-136, 2347, -478, 0, 47, 8, 0, 13, -26, 5, -58, -3]\nb = []\nc = []\nx = 0\nwhile x < len(a):\n\tif a[x] < 0:\n\t\tb.append(a[x])\n\telif a[x] > 0:\n\t\tc.append(a[x])\n\tx += 1\nprint(b)\nprint(c)",
            "output" : "[-136, -478, -26, -58, -3]\n[2347, 47, 8, 13, 5]" 
          }, {
            "index" : 10,
            "description" : "Bisher haben wir nur Elemente an das Ende einer Liste hinzugefügt. Man kann jedoch ein Element auch an einem beliebigen Index zu einer Liste hinzufügen. Dies kann mit der Funktion a.insert(i, n), wobei das Element n am Index i zur Liste a hinzugefügt wird. Füge der vorgegebenen Liste a in der Mitte das Element 'Mitte' ein und gibt die Liste aus.",
            "startingCode" : "a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]",
            "solution" : "a = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\na.insert(len(a) / 2, 'Mitte')\nprint(a)",
            "output" : "[1, 2, 3, 4, 5, Mitte, 6, 7, 8, 9, 10]"
          }, {
            "index" : 11,
            "description" : "Wenn wir ein Element in einer Liste a haben, dessen Index wir erfahren wollen, können wir diesen mit der Methode a.index(n) herausfinden. Gib den Index des Elementes Mitte aus der vorgegebenen Liste b aus.",
            "startingCode" : "b = [1, 2, 3, 4, 5, 'Mitte', 6, 7, 8, 9, 10]",
            "solution" : "b = [1, 2, 3, 4, 5, 'Mitte', 6, 7, 8, 9, 10]\nindex = b.index('Mitte')\nprint(index)",
            "output" : "6"
          }, {
            "index" : 12,
            "description" : "Die Methode a.index(n) gibt nur den Index des ersten Elementes mit dem Wert n aus, falls mehrere enthalten sind. Jedoch kann der Methode ein zweites Argument hinzugefügt werden, nämlich der Startwert für den Index, ab welchem gesucht werden soll. Eine Suche nach einem Element mit dem Wert 5 in einer Liste q ab dem Index 3 würde also folgendermassen aussehen:<code class=\"python\">q.index(5, 3)</code>Gib den Index des zweiten Elementes mit dem Wert 18 aus der Liste z aus.",
            "startingCode" : "z = [1, 18, 25, 37, 12, 34, 18, 26, 16, 18]",
            "solution" : "z = [1, 18, 25, 37, 12, 34, 18, 26, 16, 18]\nindex_0 = z.index(18)\nindex_1 = z.index(18, index_0 + 1)\nprint(index_1)",
            "output" : "6"
          }, {
            "index" : 13,
            "description" : "Es können aber nicht nur Elemente zu einer Liste hinzugefügt werden, es können auch Elemente entfernt werden. Dafür kann die Funktion a.remove(n) gebraucht werden. Mit a.remove(n) wird das erste Element aus der Liste a, das den Wert n hat entfernt. Entferne die ersten drei Elemente mit den Wert 1 aus der vorgegebenen Liste list und gibt die modifizierte Liste aus.",
            "startingCode" : "list = [1, 26, 26, 1, 36, 372, 58, 1, 4, 1, 48, 1]",
            "solution" : "list = [1, 26, 26, 1, 36, 372, 58, 1, 4, 1, 48, 1]\nx = 0\nwhile x < 3:\n\tlist.remove(1)\nprint(list)",
            "output" : "[26, 26, 36, 372, 58, 4, 1, 48, 1]"
          }, {
            "index" : 14,
            "description" : "Um herauszufinden, ob ein Wert in einer Liste enthalten ist, kann das Schüsselwort in verwendet werden. Der folgende Code testet, ob in der Liste numbers ein Element mit dem Wert 'two' enthalten ist.<code class=\"python\">a = 'two' in numbers<code> und ordnet der Variable a einen Boolean zu, also entweder True, wenn 'two' enthalten ist, oder False, wenn nicht. Schreibe ein Programm, in dem du in je einer Zeile ausgibst, ob die Werte 2, 61, 3, 'wonder' oder 6 in der Liste p enthalten sind.",
            "startingCode" : "p = [3, 24, 'wonders', 52, 61, 36, 3]",
            "solution" : "p = [3, 24, 'wonders', 52, 61, 36, 3]\nprint(2 in p)\nprint(61 in p)\nprint(3 in p)\nprint('wonder' in p)\nprint(52 in p)\nprint(61 in p)\nprint(6 in p)",
            "output" : "False\nTrue\nTrue\nFalse\nFalse"
          }, {
            "index" : 15,
            "description" : "Die range(n) Funktion erzeugt eine Liste, wobei die einzelnen Elemente die ganzen Zahlen von 0 bis (aber ohne) zum Wert n sind. Erzeige damit eine Liste a mit den Werten von 0 bis und mit 12 und gib diese aus.",
            "startingCode" : "",
            "solution" : "a = range(13)\nprint(a)",
            "output" : "[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]"
          }, {
            "index" : 16,
            "description" : "Erzeuge mit der range(n) Funktion eine Liste der zahlen von 0 bis und mit 8. Gib diese aus und verändere sie mithilfe einer While-Schlaufe zu einer Liste von 10 bis und mit 18 und gib sie wieder aus.",
            "startingCode" : "",
            "solution" : "a = range(9)\nprint(a)\nx = 0\nwhile x < len(a):a[x] += 10\nprint(a)",
            "output" : "[0, 1, 2, 3, 4, 5, 6, 7, 8]\n[10, 11, 12, 13, 14, 15, 16, 17, 18]"
          }, {
            "index" : 17,
            "description" : "Das in der letzten Aufgabe erreichte Ergebnis kann auch einfacher erzeugt werden, indem man den Startwert der range(n) Funktion verändert. Diesen kann man erreichen, indem man der Funktion einen zweiten Input gibt, der vor dem ersten Input steht. Das erste Element (mit dem Index 0) wird dann den Wert dieses Inputs annehmen. Erzeuge damit eine Liste der Zahlen von 112 bis und mit 115 und gib diese aus.",
            "startingCode" : "",
            "solution" : "a = range(112, 116)\nprint(a)",
            "output" : "[112, 113, 114, 115]"
          }]
      }, {
      "index" : 5,
      "title" : "For-Schlaufen",
      "description" : "Dieses Kapitel befasst sich mit den sogenannten For-Schlaufen. Eine For-Schlaufe in Python sieht normalerweise so aus: <code class=\"python\">for x in range(0, 3, 1):\n\tprint(x)</code>Hierbei deklariert das Keyword for, dass eine For-Schlaufe folgt. Die For-Schleife startet dann mit dem Wert x = 0, und zählt in einerschritten bis x = 3, also in diesem Fall bis x = 2. Damit kann eine For-Schleife eine While-Schleife, die lediglich zum zählen da ist gut ersetzen.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Modifiziere die Schlaufe so, dass alle ganzen Zahlen von 0 bis und mit 4 ausgegeben werden.",
          "startingCode" : "for x in range\n\tprint(x)",
          "solution" : "for x in range(0, 5, 1):\n\tprint(x)",
          "output" : "0\n1\n2\n3\n4"
          }, {
            "index" : 1,
            "description" : "Setze eine For-Schlaufe ein, um jedes zweite Element einer Liste a auszugeben.",
            "startingCode" : "a = ['erstes Element', 1, 'guter Weg', 4, 2, 'sieben', 'Geschafft!']\nfor in range():\n\ta[]",
            "solution" : "a = ['erstes Element', 1, 'guter Weg', 4, 2, 'sieben', 'Geschafft!']\nfor i in range(0, len(a), 2):\n\tprint(a[i])",
            "output" : "erstes Element\nguter Weg\n2\nGeschafft!"
          }, {
            "index" : 2,
            "description" : "Mit for e in a werden alle Elemente e einer Liste a in einer For-Schlaufe verarbeitet. Die Länge eines Strings e kann ebenfalls mit len(e) ausgegeben werden. Erstelle eine For-Schlaufe, welche jedes Element der vorgegebenen Liste a ausgiebt und in der nächsten Zeile die Länge dieses Elementes ausgiebt.",
            "startingCode" : "a = ['Element', 'Stuhl', 'Hose', 'anscheinend', 'programmieren']",
            "solution" : "a = ['Element', 'Stuhl', 'Hose', 'anscheinend', 'programmieren']\nfor e in a:\n\tprint(e)\n\tprint(len(e))",
            "output" : "Element\n7\nStuhl\n5\nHose\n4\nanscheinend\n11\nprogrammieren\n13"
          }, {
            "index" : 4,
            "description" : "Eine For-Schlaufe mit einer Range-Funktion kann auch Rückwärts zählen. Erstelle eine For-Schlaufe, die die Zahlen von 7 bis und mit 0 in absteigender Reihenfolge ausgibt.",
            "startingCode" : "",
            "solution" : "for i in range(7, -1, -1):\n\tprint(i)",
            "output" : "7\n6\n5\n4\n3\n2\n1\n0"
          }, {
            "index" : 5,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : ""
          }]
      }, {
      "index" : 6,
      "title" : "Funktionen",
      "description" : "Dieses Kapitel befasst sich mit Funktionen. Eine Funktion in Python sieht folgendermassen aus: <code class=\"python\">def a(x, y):\n\tz = x + y\n\treturn z\nprint(a(1, 3)))</code>Dabei wird nach def eine Funktion mit den Variablen x und y definiert (er können beliebig viele Varbiablen sein, durch Kommata getrennt). Die Funktion wird dann mit a(1, 3) aufgerufen und ausgeführt und mit return wird die Ausgabe ausgegeben, die danach ausserhalb gebraucht werden kann.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Definiere eine Funktion, welche die zwei vorgegebenen Variablen x und y multipliziert und das Ergebnis ausgibt.",
          "startingCode" : "x = 124\ny = 41",
          "solution" : "x = 124\ny = 41\ndef a(x, y):\n\tz = x * y\n\treturn z\nprint(a(x, y))",
          "output" : "5084"
          }, {
            "index" : 1,
            "description" : "Definiere eine Funktion, welche den Betrag einer Zahl berechnen kann. Tipp: Exponenten werden mit a ** x, also a hoch x geschrieben.",
            "startingCode" : "x = -24",
            "solution" : "x = -24\ndef Betrag(x):\n\ty = (x ** 2) ** 0.5\n\treturn y\nprint(Betrag(x))",
            "output" : "24.0" 
          }, {
            "index" : 2,
            "description" : "Definiere eine Funktion, die ausgeben kann, ob der vorgegebenen Variable p eine Primzahl zugeordent ist. Gebe das Resultat im vorgegebenen Format aus.",
            "startingCode" : "p = 120431\nprint(str(p) + ' ist keine Primzahl')\nprint(str(p) + ' ist eine Primzahl')",
            "solution" : "p = 120431\ndef isprime(p):\n\tb = True\n\t# Eine for-Schlaufe, die für jede Zahl kleiner p,\n\t# grösser 1 testet, ob sie ein Teiler ist\n\tfor i in range(2, p, 1):\n\t\t# Wenn die Zahl Teilbar ist, dann ist p keine Primzah\n\t\tif p % i == 0:\n\t\t\tprint(str(p) + ' ist keine Primzahl')\n\t\t\tb = False\n\t\t\tbreak\n\t# Wenn kein Teiler gefunden wurde ist b eine Primzahl\n\tif b == True:\n\t\tprint(str(p) + ' ist eine Primzahl')\n\treturn\nisprime(p)",
            "output" : "120431 ist eine Primzahl" 
          }, {
            "index" : 3,
            "description" : "Erweitere nun die Funktion aus der letzten Aufgabe, um eine Funktion zu finden, die eine Liste mit allen Primzahlen zwischen den Zahlen 124 und 190 erstellt und diese ausgibt.",
            "startingCode" : "def isprime(p):\n\tb = True\n\tfor i in range(2, p, 1):\n\t\tif p % i == 0:\n\t\t\tprint(str(p) + ' ist keine Primzahl')\n\t\t\tb = False\n\t\t\tbreak\n\tif b == True:\n\t\tprint(str(p) + ' ist eine Primzahl')\nisprime(p)",
            "solution" : "def listprime(x, y):\n\tc = [('Primzahlen zwischen ' + str(x) + ' und ' + str(y))]\n\t# Eine For-Schlaufe um alle Zahlen zwischen x und y\n\t# durchzugehen\n\tfor k in range(x, y, 1):\n\t\tb = True\n\t\tfor i in range(2, k, 1):\n\t\t\tif k % i == 0:\n\t\t\t\tb = False\n\t\t\t\tbreak\n\t\tif b == True:\n\t\t\tc.append(k)\n\treturn c\nprint(listprime(124, 190))",
            "output" : "['Primzahlen zwischen 124 und 190', 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181]" 
          }, {
            "index" : 4,
            "description" : "Definiere eine Funktion mit der vorgegebenen Liste a als Input, die das kleinste Element der Liste ausgibt. Benutze dafür eine For-Schlaufe. Tipp: Die Elemente einer Liste sind als Strings abgespeichert. Um sie zu vergleichen müssen sie erst mit int(a) in Integer umgewandelt werden.",
            "startingCode" : "a = [1, 5, 2, 5, 2, 1, 623, -213, 2135, 6, -13, 261, -36, 66]",
            "solution" : "a = [1, 5, 2, 5, 2, 1, 623, -213, 2135, 6, -13, 261, -36, 66]\ndef minimum(a):\n\tx = int(a[0])\n\tfor element in a:\n\t\tif x > int(element):\n\t\t\tx = int(element)\n\treturn x\nprint(minimum(a))",
            "output" : "-213" 
          }, {
            "index" : 5,
            "description" : "Definiere eine Funktion, die alle Zahlen aus der vorgegeben Liste x der Grösse nach (vom kleinsten zum grössten) sortiert. Mehrfach vorkommende Zahlen sollen dabei hintereinander aufgelistet werden.",
            "startingCode" : "x = [1, 2357, 234, 347, 3246, 2132, 23, 7, -23, -32, 7, 26]",
            "solution" : "x = [1, 2357, 234, 347, 3246, 2132, 23, 7, -23, -32, 7, 26]\ndef sort(x):\n\tfor q in range(len(x)):\n\t\tfor i in range(len(x)):\n\t\t# Wenn das Element mit dem kleineren Index\n\t\t# grösser ist wird es getauscht\n\t\t\tif x[len(x) - q - i - 1] < x[len(x) - q - 1]:\n\t\t\t\ta = x[len(x) - q - i - 1]\n\t\t\t\tx[len(x) - q - i - 1] = x[len(x) - q - 1]\n\t\t\t\tx[len(x) - q - 1] = a\n\treturn x\nprint(sort(x))",
            "output" : "[-32, -23, 1, 7, 7, 23, 26, 234, 347, 2132, 2357, 3246]" 
          }, {
            "index" : 6,
            "description" : "Bei dieser Aufgabe geht es wieder um Primzahlen. Jede Zahl kann mit ihren sogenannten Primfaktoren, also Primzahlen, die multipliziert die Zahl gegen dargestellt werden. Definiere also eine Funktion, mit der du als Input eine Zahl erhältst und als Output eine Liste der Primfaktoren erhältst, geordnet von der kleinsten zur grössten. Gibt damit die Primfaktoren der vorgegebenen Werten von x und y aus.",
            "startingCode" : "x = 28340\ny = 104500",
            "solution" : "x = 28340\ny = 104500\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\nprint(primefactors(x))\nprint(primefactors(y))",
            "output" : "[2, 2, 5, 13, 109]\n[2, 2, 5, 5, 5, 11, 19]" 
          }, {
            "index" : 7,
            "description" : "Die Aufspaltung einer Zahl in ihre Primfaktoren kann gebraucht werden um die Teiler der Zahl herauszufinden. Dabei sind also die Primfaktoren selbst auf jeden Fall Teiler, aber auch alle möglichen Multiplikationen der einzelnen Primfaktoren. Definiere nun eine zweite Funktion, die eine Liste aller Teiler (ohne 1) erstellt und gib damit alle Teiler, geordnet vom kleinsten zum grössten Teiler, der Zahl 124 aus.",
            "startingCode" : "x = 124\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "x = 124\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef dividers(n):\n\tfactors = primefactors(n)\n\tdivider = []\n\tfor i in range(len(factors)):\n\t\t# Alle Primfaktoren sind Teiler von n\n\t\tdivider.append(factors[i])\n\t\tfor j in range(i + 1, len(factors), 1):\n\t\t\tdivider.append(factors[i] * factors[j])\n\t\t\tfor k in range(j + 1, len(factors), 1):\n\t\t\t\tdivider.append(factors[i] * factors[j] *\n\t\t\t\t  factors[k])\n\t\t\t\tfor l in range(k + 1, len(factors), 1):\n\t\t\t\t\tdivider.append(factors[i] * factors[j]\n\t\t\t\t\t  * factors[k] * factors[l])\n\t# Doppelte Teiler werden entfernt\n\tx = 0\n\twhile x < len(divider):\n\t\ty = x + 1\n\t\twhile y < len(divider):\n\t\t\tif divider[x] == divider[y]:\n\t\t\t\tdivider.remove(divider[x])\n\t\t\telse:\n\t\t\t\ty += 1\n\t\tx += 1\n\t# Die Liste wird der Grösse nach geordnet\n\tfor i in range(len(divider)):\n\t\tfor j in range(i, len(divider), 1):\n\t\t\tif divider[i] > divider[j]:\n\t\t\t\tdivider[i], divider[j] = divider[j], divider[i]\n\treturn divider\n\nprint(dividers(x))",
            "output" : "[2, 4, 31, 62, 124]" 
          }, {
            "index" : 8,
            "description" : "In dieser Aufgabe wollen wir die Primfaktorenzerlegung dazu benutzen um den grössten gemeinsamen Teiler zweier Zahlen zu finden. Dieser ist dabei das Produkt aller Primfaktoren, die in beiden Zahlen vorhanden sind. Benutze also die Funktion für die Primfaktorenzerlegung und berechne mit einer neuen Funktion den grössten gemeinsamen Teiler der Zahlen 1520 und 3730 und gib ihn aus.",
            "startingCode" : "a = 1520\nb = 3730\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "a = 1520\nb = 3730\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\tfor w in range(10):\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef ggT(a, b):\n\tfactors_a = primefactors(a)\n\tfactors_b = primefactors(b)\n\t# Testen welche Faktoren in beiden vorkommen\n\tfactors_both = []\n\tfor i in range(len(factors_a)):\n\t\tfor j in range(len(factors_b)):\n\t\t\tif factors_a[i] == factors_b[j]:\n\t\t\t\tfactors_both.append(factors_a[i])\n\t\t\t\t# Das gebrauchte Element wird ersetzt,\n\t\t\t\t# damit es nur einmal gebraucht wird\n\t\t\t\tfactors_a[i] = 0\n\tggT = 1\n\tfor i in range(len(factors_both)):\n\t\tggT *= factors_both[i]\n\treturn ggT\n\nprint(ggT(a, b))",
            "output" : "80" 
          }, {
            "index" : 9,
            "description" : "Das Gegenstück zum ggT ist das kgV, das kleinste gemeinsame Vielfache zweier Zahlen. Dieses kann auch mithilfe der Primfaktoren bestimmt werden. Dabei müssen alle Primfaktoren von der ersten Zahl mit allen Primfaktoren der zweiten Zahl, ausgenommen der Primfaktoren, die bereits in der ersten Zahl vorgekommen sind multipliziert werden um das kgV zu erhalten. Definiere eine Funktion, die das kgV zweier Zahlen berechnet und gib damit das kgV von 108 und 261 aus.",
            "startingCode" : "a = 108\nb = 261\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "a = 108\nb = 261\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef kgV(a, b):\n\tfactors_a = primefactors(a)\n\tfactors_b = primefactors(b)\n\t# Die beiden Listen werden aneinandergehängt\n\tfactors_both = factors_a + factors_b\n\tfor i in range(len(factors_a)):\n\t\tfor j in range(len(factors_b)):\n\t\t\tif factors_a[i] == factors_b[j]:\n\t\t\t\tfactors_both.remove(factors_a[i])\n\t\t\t\t# Das gebrauchte Element wird ersetzt,\n\t\t\t\t# damit es nur einmal gebraucht wird\n\t\t\t\tfactors_a[i] = 0\n\tkgV = 1\n\tfor i in range(len(factors_both)):\n\t\tkgV *= factors_both[i]\n\treturn kgV\n\nprint(kgV(142, 261))",
            "output" : "1044" 
          }, {
            "index" : 10,
            "description" : "Die Aufstpaltung in die Primfaktoren kann auch sehr behilflich sein beim Vereinfachen von Brüchen. Definiere eine Funktion, die den Bruch (Format als Liste [Zähler, Nenner]) [2620, 3660] vollständig vereinfacht und ausgibt.",
            "startingCode" : "a = [2620, 3660]\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p",
            "solution" : "a = [2620, 3660]\ndef primefactors(n):\n\tp = []\n\tq = n\n\tx = True\n\twhile x:\n\t\tfor i in range(2, n + 1, 1):\n\t\t\tif q % i == 0:\n\t\t\t\tp.append(i)\n\t\t\t\tq = q / i\n\t\t\t\tbreak\n\t\t# Abbruchbedingung fuer die While-Schlaufe\n\t\ta = 1\n\t\tfor i in range(len(p)):\n\t\t\ta *= p[i]\n\t\tif a == n:\n\t\t\tx = False\n\t\t\treturn p\n\ndef simplifier(fraction):\n\ta = fraction[0]\n\tb = fraction[1]\n\tfactors_a = primefactors(a)\n\tfactors_b = primefactors(b)\n\ti = 0\n\twhile i < len(factors_a):\n\t\tj = 0\n\t\twhile j < len(factors_b):\n\t\t\tif factors_a[i] == factors_b[j]:\n\t\t\t\tfactors_a.remove(factors_a[i])\n\t\t\t\tfactors_b.remove(factors_b[j])\n\t\t\telse:\n\t\t\t\tj += 1\n\t\ti += 1\n\ta = 1\n\tfor i in range(len(factors_a)):\n\t\ta *= factors_a[i]\n\tb = 1\n\tfor i in range(len(factors_b)):\n\t\tb *= factors_b[i]\n\treturn [a, b]\n\nprint(simplifier(a))",
            "output" : "[131, 183]" 
          }, {
            "index" : 11,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 12,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 13,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 14,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 15,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 16,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 17,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }, {
            "index" : 18,
            "description" : "",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }]
      }, {
      "index" : 7,
      "title" : "Rekursive Funktionen",
      "description" : "Rekursive Funktionen werden genau gleich wie normale Funktionen definiert. Sie haben aber die Eigenschaft, dass Sie in der Funktion selbst aufgerufen wird. Wenn also eine Funktion sich selber aufruft wird sie noch einmal durchgeführt und ruft sich wieder selbst auf. Wenn das immer so weiter gehen würde, dann hätten wir eine unendliche Schlaufe kreiert. Deswegen müssen wir in der Rekursiven Funktion eine Abbruchbedingung einbauen. Die Funktion wird mit dem Codewort return a abgebrochen und gibt den Wert der Variable aus. Das unten stehende Beispiel beinhaltet eine Funktion, die eine Zahl a solange um eins erhöht, bis a den gleichen Wert wie b hat und dann abbricht und a ausgibt.<code class=\"python\">def function(a, b):\n\t# Abbruchbedingung\n\tif a >= b:\n\t\treturn a\n\telse:\n\t\ta += 1\n\t\t# Funktion wird erneut\n\t\t# aufgerufen\n\t\tfunction(a, b)</code>",
      "subexercises" : [{
          "index" : 0,
          "description" : "Definiere eine rekursive Funktion, die die Zahlen von 3 bis und mit 18 ausgibt.",
          "startingCode" : "",
          "solution" : "a = 3\nb = 19\ndef printer(a, b):\n\tif a < b:\n\t\tprint(a)\n\t\ta += 1\n\t\tprinter(a, b)\n\telse:\n\t\treturn\nprinter(a, b)",
          "output" : "3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18"
          }, {
            "index" : 1,
            "description" : "Rekursive Funktionen können auch dazu genutzt werden um rekursive Folgen auszugeben. Nun betrachten wir die Folge die wie folgt definiert ist: a_0 = 0, a_n+1 = 1 / 3* a_n + 12. Definiere eine rekursive Funktion, die eine Liste erstellt in der die ersten 10 Elemente der Funktion enthalten sind und gib diese Liste aus.",
            "startingCode" : "",
            "solution" : "a = [0]\ndef folge(n, i):\n\tif i >= n:\n\t\tprint(a)\n\t\treturn a\n\telse:\n\t\ta.append(a[i] * 1 / 3 + 12)\n\t\ti += 1\n\t\tfolge(n, i)\nfolge(9, 0)",
            "output" : "[0, 12, 16, 17, 17, 17, 17, 17, 17, 17]" 
          }, {
            "index" : 2,
            "description" : "Verändere das Programm aus der letzten Aufgabe nun so, dass die Funktion ein Argument erhält, mit dem ein Index n ausgewählt werden kann. Dadurch soll das Element aus der Folge mit diesem Index ausgegeben werden. Beachte, dass das erste Element den Index 0 hat. Gib für n = 10, n = 16, n = 153 das Element der Folge a_0 = 51, a_n+1 = 1.1 * a_n - 14 aus.",
            "startingCode" : "n = 10\nn = 23624\na_0 = 51\ndef folge(n, i):\n\tif i >= n:\n\t\treturn a\n\telse:\n\t\ta.append(a[i] * 1 / 3 + 12)\n\t\ti += 1\n\t\tfolge(n, i)\nprint(folge(10, 0))",
            "solution" : "n = 10\na_0 = 51\ndef folge(n, i, a):\n\tif i >= n:\n\t\tprint(a)\n\t\treturn a\n\telse:\n\t\ta = a * 1.1 - 14\n\t\ti += 1\n\t\tfolge(n, i, a)\nfolge(n, 0, a_0)\nn = 16\nfolge(n, 0, a_0)\nn = 153\nfolge(n, 0, a_0)",
            "output" : "-90.8430789489\n-268.952595786\n-191633097.108"
          }, {
            "index" : 3,
            "description" : "Eine andere, rekursiv sehr einfach darstellbare Folge ist die sogenannte Fibonacci-Folge. Diese ist so definiert, dass die ersten beiden Elemente beide den Wert 1 haben und jedes weitere Element aus der Summe der beiden vorangehenden Elemente besteht. Gib die ersten 50 Werte der Fibonacci Folge in je einer Zeile aus.",
            "startingCode" : "",
            "solution" : "a = 1\nb = 1\ndef fibonacci(a, b, n, i):\n\tif i >= n:\n\t\treturn\n\telse:\n\t\tif i % 2 == 0:\n\t\t\tprint(a)\n\t\t\ta += b\n\t\telse:\n\t\t\tprint(b)\n\t\t\tb += a\n\t\ti += 1\n\t\tfibonacci(a, b, n, i)\nfibonacci(a, b, 50, 0)",
            "output" : "1\n1\n2\n3\n5\n8\n13\n21\n34\n55\n89\n144\n233\n377\n610\n987\n1597\n2584\n4181\n6765\n10946\n17711\n28657\n46368\n75025\n121393\n196418\n317811\n514229\n832040\n1346269\n2178309\n3524578\n5702887\n9227465\n14930352\n24157817\n39088169\n63245986\n102334155\n165580141\n267914296\n433494437\n701408733\n1134903170\n1836311903\n2971215073\n4807526976\n7778742049\n12586269025" 
          }]
      }, {
      "index" : 8,
      "title" : "Module",
      "description" : "Dieses Kapitel befasst sich mit Modulen. In einem Modul können Variablen und hauptsächlich Funktionen gespeichert werden. In python gibt es auch Module, die bereits definiert sind, jedoch noch importiert werden müssen. Dies kann man mit import time machen, wobei time der Name des Modules ist. Um eine Funktion aus dem Modul aufzurufen muss man time.time(), also den Namen des Modules . den Namen der Funktion. In diesem Kapitel geht es hauptsächlich um die Module math und time.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Importiere das Modul math und gib den Sinus von 45 Grad aus. Beachte, dass der Winkel im Bogenmass werden muss. Mit math.sin(a) kannst du den Sinus eines Winkels ausgeben und mit math.asin() kannst du den Arcussinus einer Zahl ausgeben. Runde das Resultat mit round(x, 5) auf fünf Stellen nach dem Komma und gib es aus",
          "startingCode" : "",
          "solution" : "import math\n# Die Variable pi wird mit der Kreiszahl definiert\npi = math.asin(1) * 2\na = math.sin(45 * 2 * pi / 360)\nprint(round(a, 5))",
          "output" : "0.70711"
          }, {
            "index" : 1,
            "description" : "Importiere das Modul time. Mit time.time() kannst du nun eine Zeit in Sekunden ausgeben. Finde nun heraus, in welchem Jahr diese Zeit ihren Ursprung (also 0 war) hatte. Tipp: mit int(a) wir eine floating point Zahl in einen Integer umgewandelt, also eine Dezimalzahl zu einer ganzen Zahl abgerundet.",
            "startingCode" : "",
            "solution" : "import time\n# Die Zeit wird von Sekunden in Jahre konvertiert\nnow = time.time() / (60 * 60 * 24 * 365.24)\n# Die Zeit wird von 2020 (Ende 2019) abgezogen, um das Ursprungsjahr zu erhalten\nzero = 2020 - now\nyear = int(zero)\nprint(year)",
            "output" : "1970" 
          }, {
            "index" : 2,
            "description" : "Ein Modul kann auch mit<code class=\"python\">from time import *</code>importiert werden. Dabei kann anstelle von time ein beliebiges Modul importiert werden. Der Vorteil davon ist, dass nun die Funktionen des Moduls nicht mehr mit time.time(), sondern nur noch mit time() aufgerufen werden können. Importiere das Modul math und gib mithilfe der Funktionen log(x, Basis) und e (Eulersche Zahl) den natürlichen Logarithmus von 3.5 aus. Runde diesen mit round(x, 4) auf vier Stellen nach dem Komma.",
            "startingCode" : "",
            "solution" : "from math import *\na = log(3.5, e)\na_rounded = round(a, 4)\nprint(a_rounded)",
            "output" : "1.2528" 
          }, {
            "index" : 3,
            "description" : "Teste mithilfe des Moduls time, ob in Python 20 multipliziert 20 oder ob 20 hoch 2 schneller gerechnet wird. Tipp: Lass die Rechnung einige Male laufen, da das Ergebnis sonst zu ungenau ist. Gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print('20 mal 20 mal 20 mal 20 wird schneller gerechnet als 20 hoch 4')\nprint('20 hoch 4 wird schneller gerechnet als 20 mal 20 mal 20 mal 20')",
            "solution" : "from time import *\nt0 = time()\nfor i in range(100000):\n\t20 * 20 * 20 * 20\nt_multiply = time() - t0\nt0 = time()\nfor i in range(100000):\n\t20 ** 4\nt_power = time() - t0\nif t_multiply < t_power:\n\tprint('20 mal 20 mal 20 mal 20 wird schneller gerechnet als 20 hoch 4')\nelse:\n\tprint('20 hoch 4 wird schneller gerechnet als 20 mal 20 mal 20 mal 20')",
            "output" : "20 hoch 4 wird schneller gerechnet als 20 mal 20 mal 20 mal 20" 
          }, {
            "index" : 4,
            "description" : "Teste in diesem Programm, ob es einen Unterschied in der gebrauchten Zeit zwischen den beiden Möglichkeiten eine Addition durchzuführen: x = x + n oder x += n. Denke daran mehrere Durchläufe zu machen um ein vertrauliches Ergebnis zu erhalten und gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print('Die Operation x = x + n ist schneller')\nprint('Es sind beide Operationen etwa gleich schnell')\nprint('Die Operation x += n ist schneller')",
            "solution" : "from time import *\nx = 0\nt0 = time()\nfor i in range(1500000):\n\tx = x + 10\nt_fullwritten = time() - t0\nx = 0\nt0 = time()\nx = 0\nfor i in range(1500000):\n\tx += 10\nt_shortwritten = time() - t0\nif abs(t_fullwritten - t_shortwritten) < t_fullwritten / 100:\n\tprint('Es sind beide Operationen etwa gleich schnell')\nelif t_fullwritten < t_shortwritten:\n\tprint('Die Operation x = x + n ist schneller')\nelse:\n\tprint('Die Operation x += n ist schneller')",
            "output" : "Die Operation x = x + n ist schneller" 
          }, {
            "index" : 5,
            "description" : "Teste nach dem gleichen Prinzip wie vorher, ob eine While-Schlaufe oder eine For-Schlaufe schneller durchlaufen wird. Denke wieder daran, dies mit genug vielen Durchlaufen zu testen und gib das Resultat im vorgegebenen Format aus.",
            "startingCode" : "print('Eine For-Schlaufe ist schneller als eine While-Schlaufe')\nprint('Eine While-Schlaufe ist schneller als eine For-Schlaufe')",
            "solution" : "from time import *\nt0 = time()\nfor i in range(1000000):\n\t1000 * 1000\nt_for = time() - t0\nt0 = time()\nx = 0\nwhile x < 1000000:\n\t1000 * 1000\n\tx = x + 1\nt_while = time() - t0\nif t_for < t_while:\n\tprint('Eine For-Schlaufe ist schneller als eine While-Schlaufe')\nelse:\n\tprint('Eine While-Schlaufe ist schneller als eine For-Schlaufe')",
            "output" : "Eine For-Schlaufe ist schneller als eine While-Schlaufe" 
          }, {
            "index" : 6,
            "description" : "Mit dem Modul random können zufällig Zahlen in einer vorgegebenen Reichweite generiert werden. Dabei gibt es verschiedene Funktionen, die im Beispielcode gezeigt und im Kommentar dazu beschrieben werden.<code class=\"python\"># Das Random-Modul wird importiert\nfrom random import *\n# Generiert eine zufällige ganze Zahl zwischen 4 und (ohne) 9\nrandint(4, 9)\n# Generiert eine zufällige Fliesskommazahl zwischen 3 und (ohne) 7\nuniform(3, 7)\nx = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n# Durchmischt die Liste x\nshuffle(x)\n# Nimmt ein zufälliges Element aus der Liste\nchoice([1, 5, 2, 7, 36, 7, 26, 2])</code>",
            "startingCode" : "",
            "solution" : "",
            "output" : "" 
          }]
      }, {
      "index" : 9,
      "title" : "Klassen Einführung",
      "description" : "Dieses Kapitel befasst sich mit Klassen. Falls du mit den Funktionen noch nicht sattelfest bist empfehlen wir dir, zuerst diese Kapitel durchzuarbeiten, bevor du dich an die Klassen wagst. Klassen werden in Python folgendermassen definiert.<code class=\"python\">class calculator:\n\tdef __init__(self, x, y):\n\t\tself.x = x\n\t\tself.y = y\n\tdef sum(self):\n\t\tself.sum = self.x + self.y\n\t\treturn self.sum\ninput = calculator(2, 3)\nsumme = calculator.sum(input)\nprint(summe)</code>Am obigen Beispiel ist also erkennbar, dass eine Klasse eine Sammlung von Funktionen sein kann. Immer dabei sein muss ein __init__(self, Argument 1, Argument 2, ...). Durch diese Funktion werden die verschiedenen Eigenschaften einer Variable definiert. Wenn die Klasse nun aufgerufen wird mit n = name(Argument 1, Argument 2, ...) dann kann in der Funktion __init__ der Variable n mit n.eigenschaft = Argument 1, einer Eigenschaft von n ein Wert zugeordnet werden. Dieser kann dann in den weiteren Funktionen der Klasse aufgerufen und verarbeitet werden. Die weiteren Funktionen werden mit name.funktionsname(Argument 1, ...) aufgerufen.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Kopiere oder Schreibe das Programm aus der Kapitelbeschreibung ab füge noch ein drittes Argument z = 8 hinzu. Addiere nun die drei Werte und gib das Resultat aus.",
          "startingCode" : "z = 8",
          "solution" : "z = 8\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\ninput = calculator(2, 3, z)\nsumme = calculator.sum(input)\nprint(summe)",
          "output" : "13"
          }, {
            "index" : 1,
            "description" : "Erweitere nun das Programm aus der letzten Aufgabe um zu dem Summenrechner noch einen Produktrechner hinzuzufügen. Addiere die drei vorgegebenen Variablen nun mit der Klasse, gib das Ergebnis aus und Multipliziere die Variablen mit der Klasse und gib das Ergebnis auf einer neuen Zeile aus.",
            "startingCode" : "x = 15\ny = 25\nz = 23\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\ninput = calculator(2, 3, z)\nsumme = calculator.sum(input)\nprint(summe)",
            "solution" : "x = 15\ny = 25\nz = 23\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\tproduct()\n\t\tGibt das Produkt der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Argumente aus'''\n\t\tself.product = self.x * self.y * self.z\n\t\treturn self.product\ninput = calculator(x, y, z)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "output" : "63\n8625" 
          }, {
            "index" : 2,
            "description" :"Erweitere dass Programm der letzzen Aufgabe nun so, dass es eine Liste von mit Zahlen als Input nimmt. Gib die Summe und das Produkt der zwei vorgegebenen Variablen x und y in je einer Zeile aus.",
            "startingCode" : "x = 155\ny = 162\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tx : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\ty : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\tz : int\n\t\tEine ganze Zahl mit der gerechnet werden soll\n\n\tVerfahren\n\t-------\n\tsum()\n\t\tGibt die Summe der Attribute aus\n\tproduct()\n\t\tGibt das Produkt der Attribute aus\n\t'''\n\tdef __init__(self, x, y, z):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tx : int\n\t\t\tDie erste Zahl als input\n\t\ty : int\n\t\t\tDie zweite Zahl als input\n\t\tz : int\n\t\t\tDie dritte Zahl als input\n\t\t'''\n\t\tself.x = x\n\t\tself.y = y\n\t\tself.z = z\n\tdef sum(self):\n\t\t'''Gibt die Summe der Attribute aus'''\n\t\tself.sum = self.x + self.y + self.z\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Argumente aus'''\n\t\tself.product = self.x * self.y * self.z\n\t\treturn self.product\ninput = calculator(x, y, z)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "solution" : "x = 15\ny = 25\nlist = [x, y] # Liste mit den Elementen x und y\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe der Elemente vom Attribut aus'''\n\t\tself.sum = self.a[0] + self.a[1]\n\t\treturn self.sum\n\t\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = self.a[0] * self.a[1]\n\t\treturn self.product\ninput = calculator(list)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "output" : "40\n375" 
          }, {
            "index" : 3,
            "description" :"Erweitere dass Programm der letzten Aufgabe jetzt so, dass es eine Liste aus egal wie vielen Elementen als Input nehmen kann. Berechne damit die Summe und die Produkte aller Zahlen aus den zwei vorgegebenen Liste. Gibt die Ergebnisse in je einer Zeile und der Reihenfolge: Summe 1, Produkt 1, Summe 2, Produkt 2 aus.",
            "startingCode" : "x = [1, 164, 126, 1246, 62, 62, 168, 690, 951] # Liste als Input\ny = [399, 6, 27, 2, 7, 1, 2, 36, 6, 25] # Liste als Input\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe der Elemente vom Attribut aus'''\n\t\tself.sum = self.a[0] + self.a[1]\n\t\treturn self.sum\n\t\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = self.a[0] * self.a[1]\n\t\treturn self.product\ninput = calculator(list)\nsumme = calculator.sum(input)\nprint(summe)\nProdukt = calculator.product(input)\nprint(Produkt)",
            "solution" : "x = [1, 164, 126, 1246, 62, 62, 168, 690, 951] # Liste als Input\ny = [399, 6, 27, 2, 7, 1, 2, 36, 6, 25] # Liste als Input\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe aller Elemente vom Attribut aus'''\n\t\tself.sum = 0\n\t\tfor i in range(len(self.a)):\n\t\t\tself.sum += self.a[i]\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = 1\n\t\tfor i in range(len(self.a)):\n\t\t\tself.product *= self.a[i]\n\t\treturn self.product\ninput_1 = calculator(x)\nsumme_1 = calculator.sum(input_1)\nprint(summe_1)\nProdukt_1 = calculator.product(input_1)\nprint(Produkt_1)\ninput_2 = calculator(y)\nsumme_2 = calculator.sum(input_2)\nprint(summe_2)\nProdukt_2 = calculator.product(input_2)\nprint(Produkt_2)",
            "output" : "3470\n10910752488817413120\n511\n9773265600" 
          }, {
            "index" : 4,
            "description" :"Nun wollen wir den Taschenrechner mit einer Funktion erweitern, die ihn die Fakultät eines Inputs rechnen lässt. Gib die Fakultäten der Elemente der vorgegebenen Liste x in je einer Zeile aus. Beachte dafür dass die Fakultät von 0 per Definition 1 ist.",
            "startingCode" : "x = [22, 0, 12]\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : list\n\t\tEine Liste aus integer Werten\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : list\n\t\t\tEine Liste mit integer Werten\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe aller Elemente vom Attribut aus'''\n\t\tself.sum = 0\n\t\tfor i in range(len(self.a)):\n\t\t\tself.sum += self.a[i]\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus\n\t'''\n\t\tself.product = 1\n\t\tfor i in range(len(self.a)):\n\t\t\tself.product *= self.a[i]\n\t\treturn self.product\ninput_1 = calculator(x)\nsumme_1 = calculator.sum(input_1)\nprint(summe_1)\nProdukt_1 = calculator.product(input_1)\nprint(Produkt_1)\ninput_2 = calculator(y)\nsumme_2 = calculator.sum(input_2)\nprint(summe_2)\nProdukt_2 = calculator.product(input_2)\nprint(Produkt_2)",
            "solution" : "x = [22, 0, 12]\nclass calculator:\n\t'''\n\tEine Klasse gebraucht um Operationen zu rechnen\n\n\t...\n\n\tAttribute\n\t----------\n\ta : int\n\t\tEin Wert zum rechnen\n\tVerfahren\n\t-------\n\tsum()\n\t\tDer Elemente des Attributes aus\n\tproduct()\n\t\tGibt das Produkt der Elemente des Attributes aus\n\tfactorial()\n\t\tGibt die Fakultaet vom aufgerufenen Element aus\n\t'''\n\tdef __init__(self, a):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\ta : int\n\t\t\tEine Zahl, die als Attribut definiert wird\n\t\t'''\n\t\tself.a = a\n\tdef sum(self):\n\t\t'''Gibt die Summe der Elemente vom Attribut aus'''\n\t\tself.sum = 0\n\t\tfor i in range(len(self.a)):\n\t\t\tself.sum += self.a[i]\n\t\treturn self.sum\n\tdef product(self):\n\t\t'''Gibt das Produkt der Elemente vom Attribut aus'''\n\t\tself.product = 1\n\t\tfor i in range(len(self.a)):\n\t\t\tself.product *= self.a[i]\n\t\treturn self.product\n\tdef factorial(self, element):\n\t\t'''Gibt die Fakultaet des Elementes vom Attribut aus'''\n\t\tself.factorial = 1\n\t\tfor i in range(self.a[element]):\n\t\t\tself.factorial *= self.a[element] - i\n\t\treturn self.factorial\nfor i in range(len(x)):\n\tprint(calculator.factorial(calculator(x), i))",
            "output" : "1124000727777607680000\n1\n479001600" 
          }]
      }, {
      "index" : 10,
      "title" : "Klassen Fortgeschritten",
      "description" : "Wenn dir die Einführung in die Klassen zu leicht ist, du dich aber trotzdem mit Klassen beschäftigen willst, dann empfehlen wir dir dieses Kapitel. Wenn du dich jedoch noch nie mit Klassen befasst hast empfehlen wir dir das letzte Kapitel, die Einführung in die Klassen.",
      "subexercises" : [{
          "index" : 0,
          "description" : "Definiere eine Klasse, die in der Lage ist die Gravitationskraft zwischen zwei Objekten nach dem Newtonschen Gravitationsgesetz zu berechenen. Benutze dafür die vorgegebenen und gib die Kraft auf die Masse_1 zuerst und in der darauffolgenden Zeile die Kraft auf die Masse_2 aus. Runde die Kräfte mit round(x, 4) auf 4 Stellen nach dem Komma.",
          "startingCode" : "mass_1 = 15000 # Masse in kg\nmass_2 = 37500 # Masse in kg\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\ndistance = 0.05 # Distanz (m)",
          "solution" : "mass_1 = 15000 # Masse in kg\nmass_2 = 37500 # Masse in kg\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\ndistance = 0.05 # Distanz (m)\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tzwei Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tdistance : int\n\t\tDie Distanz zu dem interagierenden Objekt\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\t'''\n\tdef __init__(self, mass, distance):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\t\tDie Masse des Objektes\n\t\tdistance : int\n\t\t\tDie Distanz zu dem interagierenden Objekt\n\t\t'''\n\t\tself.mass = mass\n\t\tself.distance = distance\n\tdef force(self, interactor_mass):\n\t\t'''Gibt die Kraft auf das Objekt aus'''\n\t\tforce = (G * self.mass * interactor_mass /\n\t  self.distance ** 2)\n\t\treturn force\nobject_1 = gravitation(mass_1, distance)\nobject_2 = gravitation(mass_2, distance)\nforce_1 = gravitation.force(object_1, object_2.mass)\nforce_2 = gravitation.force(object_2, object_1.mass)\nprint(round(force_1, 4))\nprint(round(force_2, 4))",
          "output" : "15.0165\n15.0165"
          }, {
            "index" : 1,
            "description" : "Definiere eine Klasse, die folgende Operationen mit n-dimensionalen Vektoren durchführen kann: Addition mit einem Vektor, Multiplikation mit einer Konstante, Länge des Vektors (magnitude), Einheitsvektor (norm). Gib die Länge des Vektor_1, die Norm des Vektor_2, das Produkt von 3 und dem Vektor_3 und die Addition von Vektor_2 und Vektor_4 in je einer Zeile aus. Runde die Zahlen mit der bereits implementierten Funktion round(x, 4). Beachte dabei, dass du nur skalare Werte addieren, runden oder multiplizieren kannst.",
            "startingCode" : "vector_1 = [1, 7, 156]\nvector_2 = [6, 262, 2]\nvector_3 = [1, 0, 25]\nvector_4 = [6, 26, 291]",
            "solution" : "vector_1 = [1, 7, 156]\nvector_2 = [6, 262, 2]\nvector_3 = [1, 0, 25]\nvector_4 = [6, 26, 291]\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\nvec1 = vectorcalculator(vector_1)\nvec2 = vectorcalculator(vector_2)\nvec3 = vectorcalculator(vector_3)\nvec4 = vectorcalculator(vector_4)\nprint(round(vectorcalculator.magnitude(vec1), 4))\nprint(vectorcalculator.norm(vec2))\nprint(vectorcalculator.multiplication(vec3, 3))\nprint(vectorcalculator.addition(vec2, vector_4))",
            "output" : "156.1602\n[0.0229, 0.9997, 0.0076]\n[3, 0, 75]\n[12, 288, 293]" 
          }, {
            "index" : 2,
            "description" : "In der ersten Aufgabe haben mit einer Klasse die Gravitationskraft zwischen zwei Objekten berechnet. Wir wollen der Klasse nun beliebig viele Objekte als Input geben. Deswegen können wir auch nicht mehr eine skalare Zahl als Distanz Input nehmen, sondern wir brauchen vektorielle Positionen. Diese werden mit einer Liste [x, y, z] gegeben. Tipp: alle Objekte wirken Gravitationskräfte auf alle Objekte aus, verwende also eine Liste für self.interactors. Gib die Kräfte auf die einzelnen Objekte der Indexe nach geordnet in je einer Zeile aus und runde sie mit round(x, 4) auf vier Stellen nach dem Komma. Verwende für die Berechnungen die Klasse für das Vektorenrechnen aus der letzten Aufgabe.",
            "startingCode" : "mass_1 = 236 # Masse in kg\nmass_2 = 339 # Masse in kg\nmass_3 = 3079 # Masse in kg\nmass_4 = 306 # Masse in kg\nposition_1 = [1, 5, 2] # Position [x, y, z] (m)\nposition_2 = [6, 26, 2] # Position [x, y, z] (m)\nposition_3 = [1, 0, 0] # Position [x, y, z] (m)\nposition_4 = [6, 1, 2] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\nvec1 = vectorcalculator(vector_1)\nvec2 = vectorcalculator(vector_2)\nvec3 = vectorcalculator(vector_3)\nvec4 = vectorcalculator(vector_4)\nprint(round(vectorcalculator.magnitude(vec1), 4))\nprint(vectorcalculator.norm(vec2))\nprint(vectorcalculator.multiplication(vec3, 3))\nprint(vectorcalculator.addition(vec2, vector_4))",
            "solution" : "mass_1 = 236124 # Masse in kg\nmass_2 = 339501 # Masse in kg\nmass_3 = 307900 # Masse in kg\nmass_4 = 306150 # Masse in kg\nposition_1 = [1, 5, 2] # Position [x, y, z] (m)\nposition_2 = [6, 26, 2] # Position [x, y, z] (m)\nposition_3 = [1, 0, 0] # Position [x, y, z] (m)\nposition_4 = [6, 1, 2] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Gibt die Kraft aus, die auf das Objekt wirkt'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt ein Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nobject_1 = gravitation(mass_1, position_1)\nobject_2 = gravitation(mass_2, position_2)\nobject_3 = gravitation(mass_3, position_3)\nobject_4 = gravitation(mass_4, position_4)\nobject_1.set_interactors([object_2, object_3, object_4])\nobject_2.set_interactors([object_1, object_3, object_4])\nobject_3.set_interactors([object_1, object_2, object_4])\nobject_4.set_interactors([object_1, object_2, object_3])\nforce_1 = [0, 0, 0]\nforce_2 = [0, 0, 0]\nforce_3 = [0, 0, 0]\nforce_4 = [0, 0, 0]\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "output" : "[0.0946, -0.2177, -0.0621]\n[-0.0046, -0.032, -0.0007]\n[0.1933, 0.2034, 0.1394]\n[-0.2833, 0.0463, -0.0766]" 
          }, {
            "index" : 3,
            "description" : "Im letzten Programm mussten wir mühsam die interactors mit set_interactors definieren. Dies geht auch effizienter. Verbessere den Code des vorgerigen Programms um das Programm kürzer zu schreiben. Die Ausgabe soll wieder aus den Kräften, die auf die Objekte wirken, mit auf vier Stellen nach dem Komma gerundeten Zahlen bestehen.",
            "startingCode" : "mass_1 = 235232 # Masse in kg\nmass_2 = 362363 # Masse in kg\nmass_3 = 624653 # Masse in kg\nmass_4 = 773150 # Masse in kg\nposition_1 = [1, 6, 2] # Position [x, y, z] (m)\nposition_2 = [13, 26, 21] # Position [x, y, z] (m)\nposition_3 = [0, 0, 0] # Position [x, y, z] (m)\nposition_4 = [10, -1, -1] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nobject_1 = gravitation(mass_1, position_1)\nobject_2 = gravitation(mass_2, position_2)\nobject_3 = gravitation(mass_3, position_3)\nobject_4 = gravitation(mass_4, position_4)\nobject_1.set_interactors([object_2, object_3, object_4])\nobject_2.set_interactors([object_1, object_3, object_4])\nobject_3.set_interactors([object_1, object_2, object_4])\nobject_4.set_interactors([object_1, object_2, object_3])\nforce_1 = [0, 0, 0]\nforce_2 = [0, 0, 0]\nforce_3 = [0, 0, 0]\nforce_4 = [0, 0, 0]\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "solution" : "mass_1 = 235232 # Masse in kg\nmass_2 = 362363 # Masse in kg\nmass_3 = 624653 # Masse in kg\nmass_4 = 773150 # Masse in kg\nposition_1 = [1, 6, 2] # Position [x, y, z] (m)\nposition_2 = [13, 26, 21] # Position [x, y, z] (m)\nposition_3 = [0, 0, 0] # Position [x, y, z] (m)\nposition_4 = [10, -1, -1] # Position [x, y, z] (m)\nglobal G\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nclass vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nobject_1 = gravitation(mass_1, position_1)\nobject_2 = gravitation(mass_2, position_2)\nobject_3 = gravitation(mass_3, position_3)\nobject_4 = gravitation(mass_4, position_4)\nsystem = [object_1, object_2, object_3, object_4]\nfor i in range(len(system)):\n\tinteractors = [object_1, object_2, object_3, object_4]\n\tdel interactors[i]\n\tsystem[i].set_interactors(interactors)\n\t\nforce_1 = [0, 0, 0]\nforce_2 = [0, 0, 0]\nforce_3 = [0, 0, 0]\nforce_4 = [0, 0, 0]\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "output" : "[0.0318, -0.2717, -0.0929]\n[-0.0081, -0.0245, -0.0205]\n[0.3546, 0.2013, 0.0503]\n[-0.3783, 0.0949, 0.0631]" 
          }, {
            "index" : 4,
            "description" : "In der vorherigen Aufgabe haben wir lediglich die Kräfte berechnet, die auf ein Objekt wirken. Nun schauen wir uns eine Anwendung davon an. Wenn wir die Kraft auf ein Objekt kennen, dann können wir mit dem Zweiten Netownschen Gesetz (F = m * a) die Beschleunigung berechnen. Mit der Beschleunigung und einer Anfangsgeschwindigkeit könne wir also die Geschwindigkeit nach einem Zeitintervall (dt) berechnen. Ebenso können wir aus der Anfangsposition die Position nach dem Zeitintervall (dt) berechnen, indem wir die Geschwindikeit als Änderungsrate der Position nehmen. In dieser Aufgabe handelt es sich um eine Bewegung in nur einer Dimension. Gib in immer einer neuen Zeile die Geschwindigkeit und die Position in jedem Zeitintervall dt aus und lasse es bis t_max = 5 Sekunden laufen. Benütze dafür die vorgegebenen Konstanten und denke daran SI-Einheiten zu verwenden. Dies ist lediglich eine Einführunsaufgabe, die Verwendung einer Klasse ist nicht nötig.",
            "startingCode" : "dt = 0.1 # Zeitintervall (s)\n # Masse des betrachteten Objektes (kg)\nmass = 10\n# Kraft während den ersten drei Sekunden (N)\nforce_1 = 100\n# Kraft nach der dritten Sekunde (N)\nforce_2 = -150\n# Zeit, zu der abgebrochen werden soll (s)\nt_max = 5\n# Anfangsposition (m)\npos = 0\n# Anfangsgeschwindigkeit (m/s)\nvelocity = 0\n# Anfangszeit der Simulation\nt = 0",
            "solution" : "dt = 0.1 # Zeitintervall (s)\n # Masse des betrachteten Objektes (kg)\nmass = 10\n# Kraft während den ersten drei Sekunden (N)\nforce_1 = 100\n# Kraft nach der dritten Sekunde (N)\nforce_2 = -150\n# Zeit, zu der abgebrochen werden soll (s)\nt_max = 5\n# Anfangsposition (m)\npos = 0\n# Anfangsgeschwindigkeit (m/s)\nvelocity = 0\n# Anfangszeit der Simulation\nt = 0\nwhile t < t_max:\n\tif t < 3:\n\t\tvelocity += force_1 / mass * dt\n\t\tpos += velocity * dt\n\t\tprint(velocity)\n\t\tprint(pos)\n\telse:\n\t\tvelocity += force_2 / mass * dt\n\t\tpos += velocity * dt\n\t\tprint(velocity)\n\t\tprint(pos)\n\tt += dt",
            "output" : "1.0\n0.1\n2.0\n0.3\n3.0\n0.6\n4.0\n1.0\n5.0\n1.5\n6.0\n2.1\n7.0\n2.8\n8.0\n3.6\n9.0\n4.5\n10.0\n5.5\n11.0\n6.6\n12.0\n7.8\n13.0\n9.1\n14.0\n10.5\n15.0\n12.0\n16.0\n13.6\n17.0\n15.3\n18.0\n17.1\n19.0\n19.0\n20.0\n21.0\n21.0\n23.1\n22.0\n25.3\n23.0\n27.6\n24.0\n30.0\n25.0\n32.5\n26.0\n35.1\n27.0\n37.8\n28.0\n40.6\n29.0\n43.5\n30.0\n46.5\n28.5\n49.35\n27.0\n52.05\n25.5\n54.6\n24.0\n57.0\n22.5\n59.25\n21.0\n61.35\n19.5\n63.3\n18.0\n65.1\n16.5\n66.75\n15.0\n68.25\n13.5\n69.6\n12.0\n70.8\n10.5\n71.85\n9.0\n72.75\n7.5\n73.5\n6.0\n74.1\n4.5\n74.55\n3.0\n74.85\n1.5\n75.0\n0.0\n75.0\n-1.5\n74.85" 
          }, {
            "index" : 5,
            "description" : "Jetzt wollen wir das neu Gelernte aus der letzten Aufgabe in das Programm aus der vorletzten Aufgabe einbauen. Nun gibt es auch ein reales Anwendungsbeispiel. Definiere eine Klasse, die allen vorgegebenen Planeten (unseeres Sonnensystems) mit den vorgegebenen Eigenschaften die auf sie wirkende Gravitationskraft berechnet und den Namen des Planeten, die Geschwindigkeit und die Position in jedem Zeitintervall dt in einer Zeile aus gibt (pro Planet eine Zeile mit einem Abstand zwischen jeder Eigenschaft und behalte die Rundungsfunktionen in der Klasse vectorcalculator bei).",
            "startingCode" : "class vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\t'''\n\tdef __init__(self, mass, position):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.mass = mass\n\t\tself.position = position\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\nAE = 149597870700 # Astronomische Einheit (m/AE)\n# Inputs für die Klasse:\ndt = 10000 # Zeitintervall (s)\n# gravitation(Name (string), Masse (kg),\n# Position [x, z, z] (m), Geschwindigkeit [x, y, z] (m/s)\nsun = gravitation('Sonne', 1.989e30,\n  [0, 0, 0], [0, 0, 0])\nmerkur = gravitation('Merkur', 3.301e23, 4897400,\n  [0.387099 * AE, 0, 0], [0, 47360, 0])\nvenus = gravitation('Venus', 4.8675e24,\n  [0.723 * AE, 0, 0], [0, 35020, 0])\nearth = gravitation('Erde', 5.972e24,\n  [1 * AE, 0, 0], [0, 29780, 0])\nmars = gravitation('Mars', 6.419e23,\n  [1.524 * AE, 0, 0], [0, 24130, 0])\njupiter = gravitation('Jupiter', 1.899e27,\n  [5.203 * AE, 0, 0], [0, 13070, 0])\nsaturn = gravitation('Saturn', 5.685e26,\n  [9.5826  * AE, 0, 0], [0, 9690, 0])\nuranus = graviation('Uranus', 8.683e25,\n  [19.201 * AE, 0, 0], [0, 6810, 0])\nneptun = gravitation('Neptun', 1.0243e26,\n  [30.07 * AE, 0, 0], [0, 5430, 0])\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\nfor i in range(len(gravitation.force(object_1))):\n\tforce_1[i] = round(gravitation.force(object_1)[i], 4)\nfor i in range(len(gravitation.force(object_2))):\n\tforce_2[i] = round(gravitation.force(object_2)[i], 4)\nfor i in range(len(gravitation.force(object_3))):\n\tforce_3[i] = round(gravitation.force(object_3)[i], 4)\nfor i in range(len(gravitation.force(object_4))):\n\tforce_4[i] = round(gravitation.force(object_4)[i], 4)\nprint(force_1)\nprint(force_2)\nprint(force_3)\nprint(force_4)",
            "solution" : "class vectorcalculator:\n\t'''\n\tEine Klasse die gebraucht wird, um einfache\n\tRechenoperationen mit Vektoren durchzufuehren\n\n\t...\n\n\tAttribute\n\t----------\n\tvector_1 : list\n\t\tDer Vektor als Liste dargestellt\n\tVerfahren\n\t-------\n\taddition(vec2)\n\t\tDie Addition von zwei Vektoren\n\tmultiplication(factor)\n\t\tDie Multiplikation einer Konstante und eines Vektors\n\tmagnitude()\n\t\tBerechnung der Magnitude (Laenge) eines Vektors\n\tnorm()\n\t\tBerechnung der Norm (Einheitsvektor) eines Vektors\n\t'''\n\tdef __init__(self, vector_1):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tvector_1 : list\n\t\t\tDer Vektor, als Liste dargestellt\n\t\t'''\n\t\tself.vec1 = vector_1\n\tdef addition(self, vec2):\n\t\t'''Gibt das Resultat der Addition zweier Vektoren aus'''\n\t\tself.vecadded = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecadded.append(round(self.vec1[i] +\n\t\t\t  vec2[i], 4))\n\t\treturn self.vecadded\n\tdef multiplication(self, factor):\n\t\t'''Gibt das Resultat der Multiplikation eines\n\t\tVektors und einer Konstante aus'''\n\t\tself.vecmultiplied = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.vecmultiplied.append(round(self.vec1[i] *\n\t\t\t  factor, 4))\n\t\treturn self.vecmultiplied\n\tdef magnitude(self):\n\t\t'''Gibt die Laenge eines Vektors aus'''\n\t\tself.magnitude = 0\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.magnitude += self.vec1[i] ** 2\n\t\tself.magnitude = self.magnitude ** 0.5\n\t\treturn self.magnitude\n\tdef norm(self):\n\t\t'''Gibt die Norm eines Vektors aus'''\n\t\tself.norm = []\n\t\tfor i in range(len(self.vec1)):\n\t\t\tself.norm.append(round(self.vec1[i] * 1 /\n\t\t\t  vectorcalculator.magnitude(self), 4))\n\t\treturn self.norm\n\nclass gravitation:\n\t'''\n\tEine Klasse gebraucht um die Gravitationskraft zwischen\n\tbeliebig vielen Objekten zu berechnen\n\n\t...\n\n\tAttribute\n\t----------\n\tmass : int\n\t\tDie Masse des Objektes\n\tVerfahren\n\t-------\n\tforce()\n\t\tDie Kraft die auf das Objekt wirkt\n\tset_interactors(objects)\n\t\tDie Objekte, die mit dem Objekt interagieren\n\tdistance(interactor)\n\t\tDie Distanz zwischen dem Objekt und dem Interaktor\n\tupdate()\n\t\tDie Geschwindigkeit und die Position nach dt\n\t'''\n\tdef __init__(self, name, mass, position, velocity):\n\t\t'''\n\t\tParameter\n\t\t----------\n\t\tmass : int\n\t\tDie Masse des Objektes\n\t\tposition : list\n\t\tDie vektorielle Position des Objektes als Liste\n\t\t'''\n\t\tself.name = name\n\t\tself.mass = mass\n\t\tself.position = position\n\t\tself.velocity = velocity\n\tdef force(self):\n\t\t'''Berechnet die Graviationskraft als und gibt\n\t\tsie als Kraftvektor (Liste) aus'''\n\t\tforce = [0, 0, 0]\n\t\tfor i in range(len(self.interactors)):\n\t\t\tdistancevec = (gravitation.distance(\n\t\t\t  self, self.interactors[i].position))\n\t\t\tforce = vectorcalculator.addition(vectorcalculator(force),\n\t\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t\t  vectorcalculator.norm(vectorcalculator(distancevec))),\n\t\t\t  G * self.mass * self.interactors[i].mass /\n\t\t\t  vectorcalculator.magnitude(\n\t\t\t  vectorcalculator(distancevec)) ** 2))\n\t\treturn force\n\tdef set_interactors(self, objects):\n\t\t'''Gibt dem Objekt den Attribut mit den Interaktoren'''\n\t\tself.interactors = objects\n\tdef distance(self, interactor):\n\t\t'''Gibt die Distanz zwischen Objekt\n\t\tund Interaktor vektoriell aus'''\n\t\tself.vecdistance = vectorcalculator.addition(\n\t\t  vectorcalculator(interactor),\n\t\t  vectorcalculator.multiplication(\n\t\tvectorcalculator(self.position), -1))\n\t\treturn self.vecdistance\n\tdef update(self):\n\t\t'''Veraendert die Geschwindigkeit und\n\t\tdie Position und gibt diese aus'''\n\t\tself.velocity = vectorcalculator.addition(\n\t\t  vectorcalculator(self.velocity),\n\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t  vectorcalculator.multiplication(\n\t\t  vectorcalculator(gravitation.force(self))\n\t\t  , 1 / self.mass)), dt))\n\t\tself.position = vectorcalculator.addition(\n\t\t  vectorcalculator(self.position),\n\t\t  vectorcalculator.multiplication(vectorcalculator(\n\t\t  self.velocity), dt))\n\t\tprint(self.name + ' ' + str(self.position) + ' ' +\n\t\t  str(self.velocity))\nAE = 149597870700 # Astronomische Einheit (m/AE)\nG = 6.674 * 10 ** (-11) #Gravitationskonstante (m^3/(kg*s^2))\n# Inputs für die Klasse:\n# gravitation(Name (string), Masse (kg),\ndt = 10000 # Zeitintervall (s)\n# Position [x, z, z] (m), Geschwindigkeit [x, y, z] (m/s)\nsun = gravitation('Sonne', 1.989e30,\n  [0, 0, 0], [0, 0, 0])\nmerkur = gravitation('Merkur', 3.301e23,\n  [0.387099 * AE, 0, 0], [0, 47360, 0])\nvenus = gravitation('Venus', 4.8675e24,\n  [0.723 * AE, 0, 0], [0, 35020, 0])\nearth = gravitation('Erde', 5.972e24,\n  [1 * AE, 0, 0], [0, 29780, 0])\nmars = gravitation('Mars', 6.419e23,\n  [1.524 * AE, 0, 0], [0, 24130, 0])\njupiter = gravitation('Jupiter', 1.899e27,\n  [5.203 * AE, 0, 0], [0, 13070, 0])\nsaturn = gravitation('Saturn', 5.685e26,\n  [9.5826  * AE, 0, 0], [0, 9690, 0])\nuranus = gravitation('Uranus', 8.683e25,\n  [19.201 * AE, 0, 0], [0, 6810, 0])\nneptun = gravitation('Neptun', 1.0243e26,\n  [30.07 * AE, 0, 0], [0, 5430, 0])\nsystem = [sun, merkur, venus, earth, mars, jupiter, saturn,\n  uranus, neptun]\nfor i in range(len(system)):\n\tinteractors = [sun, merkur, venus, earth, mars, jupiter,\n  saturn, uranus, neptun]\n\tdel interactors[i]\n\tsystem[i].set_interactors(interactors)\nfor i in range(0, 10 * dt, dt):\n\tfor i in range(len(system)):\n\t\tsystem[i].update()",
            "output" : "Sonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57905226150.1, 473600000.0, 0.0] [-396.0, 47360.0, 0.0]\nVenus [108158130516.0, 350200000.0, 0.0] [-113.0, 35020.0, 0.0]\nErde [149597280700.0, 297800000.0, 0.0] [-59.0, 29780.0, 0.0]\nMars [227986894947.0, 241300000.0, 0.0] [-26.0, 24130.0, 0.0]\nJupiter [778357701252.0, 130700000.0, 0.0] [-2.0, 13070.0, 0.0]\nSaturn [1.43353654577e+12, 96900000.0, 0.0] [-1.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 68100000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 54300000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57897306150.1, 947170000.0, 0.0] [-792.0, 47357.0, 0.0]\nVenus [108155870516.0, 700400000.0, 0.0] [-226.0, 35020.0, 0.0]\nErde [149596100700.0, 595600000.0, 0.0] [-118.0, 29780.0, 0.0]\nMars [227986374947.0, 482600000.0, 0.0] [-52.0, 24130.0, 0.0]\nJupiter [778357661252.0, 261400000.0, 0.0] [-4.0, 13070.0, 0.0]\nSaturn [1.43353652577e+12, 193800000.0, 0.0] [-2.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 136200000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 108600000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57885426150.1, 1420680000.0, 0.0] [-1188.0, 47351.0, 0.0]\nVenus [108152480516.0, 1050590000.0, 0.0] [-339.0, 35019.0, 0.0]\nErde [149594330700.0, 893400000.0, 0.0] [-177.0, 29780.0, 0.0]\nMars [227985594947.0, 723900000.0, 0.0] [-78.0, 24130.0, 0.0]\nJupiter [778357601252.0, 392100000.0, 0.0] [-6.0, 13070.0, 0.0]\nSaturn [1.43353649577e+12, 290700000.0, 0.0] [-3.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 204300000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 162900000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57869586150.1, 1894090000.0, 0.0] [-1584.0, 47341.0, 0.0]\nVenus [108147960516.0, 1400770000.0, 0.0] [-452.0, 35018.0, 0.0]\nErde [149591970700.0, 1191200000.0, 0.0] [-236.0, 29780.0, 0.0]\nMars [227984554947.0, 965200000.0, 0.0] [-104.0, 24130.0, 0.0]\nJupiter [778357521252.0, 522800000.0, 0.0] [-8.0, 13070.0, 0.0]\nSaturn [1.43353645577e+12, 387600000.0, 0.0] [-4.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 272400000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 217200000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57849786150.1, 2367370000.0, 0.0] [-1980.0, 47328.0, 0.0]\nVenus [108142310516.0, 1750940000.0, 0.0] [-565.0, 35017.0, 0.0]\nErde [149589020700.0, 1489000000.0, 0.0] [-295.0, 29780.0, 0.0]\nMars [227983254947.0, 1206500000.0, 0.0] [-130.0, 24130.0, 0.0]\nJupiter [778357421252.0, 653500000.0, 0.0] [-10.0, 13070.0, 0.0]\nSaturn [1.43353640577e+12, 484500000.0, 0.0] [-5.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 340500000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 271500000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57826026150.1, 2840490000.0, 0.0] [-2376.0, 47312.0, 0.0]\nVenus [108135530516.0, 2101090000.0, 0.0] [-678.0, 35015.0, 0.0]\nErde [149585480700.0, 1786790000.0, 0.0] [-354.0, 29779.0, 0.0]\nMars [227981694947.0, 1447800000.0, 0.0] [-156.0, 24130.0, 0.0]\nJupiter [778357301252.0, 784200000.0, 0.0] [-12.0, 13070.0, 0.0]\nSaturn [1.43353634577e+12, 581400000.0, 0.0] [-6.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 408600000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 325800000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57798306150.1, 3313420000.0, 0.0] [-2772.0, 47293.0, 0.0]\nVenus [108127620516.0, 2451220000.0, 0.0] [-791.0, 35013.0, 0.0]\nErde [149581350700.0, 2084570000.0, 0.0] [-413.0, 29778.0, 0.0]\nMars [227979874947.0, 1689100000.0, 0.0] [-182.0, 24130.0, 0.0]\nJupiter [778357161252.0, 914900000.0, 0.0] [-14.0, 13070.0, 0.0]\nSaturn [1.43353627577e+12, 678300000.0, 0.0] [-7.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 476700000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 380100000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57766636150.1, 3786120000.0, 0.0] [-3167.0, 47270.0, 0.0]\nVenus [108118580516.0, 2801320000.0, 0.0] [-904.0, 35010.0, 0.0]\nErde [149576630700.0, 2382340000.0, 0.0] [-472.0, 29777.0, 0.0]\nMars [227977794947.0, 1930400000.0, 0.0] [-208.0, 24130.0, 0.0]\nJupiter [778357001252.0, 1045600000.0, 0.0] [-16.0, 13070.0, 0.0]\nSaturn [1.43353619577e+12, 775200000.0, 0.0] [-8.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 544800000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 434400000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57731016150.1, 4258560000.0, 0.0] [-3562.0, 47244.0, 0.0]\nVenus [108108410516.0, 3151390000.0, 0.0] [-1017.0, 35007.0, 0.0]\nErde [149571320700.0, 2680100000.0, 0.0] [-531.0, 29776.0, 0.0]\nMars [227975454947.0, 2171700000.0, 0.0] [-234.0, 24130.0, 0.0]\nJupiter [778356821252.0, 1176300000.0, 0.0] [-18.0, 13070.0, 0.0]\nSaturn [1.43353610577e+12, 872100000.0, 0.0] [-9.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 612900000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 488700000.0, 0.0] [0.0, 5430.0, 0.0]\nSonne [0.0, 0.0, 0.0] [0.0, 0.0, 0.0]\nMerkur [57691446150.1, 4730710000.0, 0.0] [-3957.0, 47215.0, 0.0]\nVenus [108097110516.0, 3501430000.0, 0.0] [-1130.0, 35004.0, 0.0]\nErde [149565420700.0, 2977850000.0, 0.0] [-590.0, 29775.0, 0.0]\nMars [227972854947.0, 2413000000.0, 0.0] [-260.0, 24130.0, 0.0]\nJupiter [778356621252.0, 1307000000.0, 0.0] [-20.0, 13070.0, 0.0]\nSaturn [1.43353600577e+12, 969000000.0, 0.0] [-10.0, 9690.0, 0.0]\nUranus [2.87242871531e+12, 681000000.0, 0.0] [0.0, 6810.0, 0.0]\nNeptun [4.49840797195e+12, 543000000.0, 0.0] [0.0, 5430.0, 0.0]" 
          }]
      }
    ]
}
