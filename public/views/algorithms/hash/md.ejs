<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Message-Digest Algorithmus</title>
    <link rel="shortcut icon" type="image/x-icon" href="/imgs/favicon.ico"/>
    <link rel="stylesheet" href=<%= "/styles/" + path + ".css" %>>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P|Righteous" rel="stylesheet">
    <script src=<%= "/js/" + path + ".js" %> type="text/javascript"></script>
    <script src="/js/codeHighlighting.js" type="text/javascript"></script>
    <script type="text/javascript">
      const codeHighlighting = <%- JSON.stringify(codeHighlighting) %>;
    </script>
  </head>
  <body onload="hash(''); addHighlighting();">
    <%- include ../../partials/header.ejs %>
    <main>
      <div class="title">
        <h1>Message Digest Hash-Algorithmus</h1>
      </div>
      <div class="pageShortcuts">
        <h2>Page Shortcuts</h2>
        <ul>
          <li><a href="#history">Geschichte</a></li>
          <li><a href="#usage">Gebrauch</a></li>
          <li><a href="#specs">Spezifikationen</a></li>
          <li><a href="#functionality">Funktionsweise</a></li>
          <li><a href="#exampleCode">Beispielcode</a><ul>
            <li><a href="#java">Java</a></li>
          </ul></li>
          <li><a href="#hasher">Text-Hasher</a></li>
        </ul>
      </div>
      <div class="text">
        <div id="history">
          <h2>Geschichte</h2>
          <p>Die Serie der Message Digest Algorithmen wurde ursprünglich von Ronald Rivest vom MIT entwickelt.</p>
          <p>Im Jahre 1991 entwickelte er den MD5 Algorithmus, nachdem Analysen gezeigt haben, dass der MD4-Algorithmus höchstwahrscheinlich unsicher ist.</p>
        </div>
        <div id="usage">
          <h2>Gebrauch</h2>
          <p>Aufgrund der <a href="#specs">kritischen Schwachstellen</a> des Algorithmus sollte er nie zur Verschlüsselung von Daten verwendet werden.</p>
          <p>Heutzutage wird der MD-Algorithmus hauptsächlich zur Kreierung von digital Fingerprints benutzt. Diese sind nützlich, um zu überprüfen, ob keine Daten bei Übertragungen verloren gegangen sind, da eine Datei vor und nach der Transmission den gleichen Hash mit sich bringt, falls kein Datenverlust stattgefunden hat.</p>
        </div>
        <div id="specs">
          <h2>Spezifikationen</h2>
          <p>Der MD-Algorithmus produziert einen 128-Bit Hash.</p>
          <p>Somit kann er 2<sup>128</sup> (Circa 3.4 ∗ 10<sup>38</sup>) einzigartige Hashes hervorbringen.</p>
          <p>Trotzdessen wird er heute als unsicher klassifiziert. Manchmal genügt lediglich eine schnelle <a href="https://www.google.com/search?q=276f8db0b86edaa7fc805516c852c889&rlz=1C1CHBF_deCH819CH819&oq=276f8db0b86edaa7fc805516c852c889&aqs=chrome..69i57.411j0j7&sourceid=chrome&ie=UTF-8" target="_blank">Google Suche</a> eines Hashes, um dessen Ursprung herauszufinden.</p>
          <p>Aufgrund der schnellen Generierung eines MD-Hashes ist es relativ einfach, eine Kollision zu bruteforcen.</p>
          <p>Eine Kollision eines MD5-Hashes kann durch Anwendung von verschiedenen Tricks in 15-60 Minuten gefunden werden, wobei dies bei einem MD4-Hash weniger als eine Sekunde dauert.</p>
        </div>
        <div id="functionality">
          <h2>Funktionsweise</h2>
          <p>Als erstes wird die Nachricht in Bits umgewandelt. Anschliessend folgt das Padding. Gepaddet wird, indem ein Bit von eins angefügt wird und dann so lange Bits von null, bis die Länge der Nachricht Modulo 512 448 ergibt. Anschliessend wird eine 64-Bit Repräsentation der originalen Länge der Nachricht angefügt.</p>
          <p>Nun müssen vier Startwerte deklariert werden. Sie besitzen folgende Startwerte:</p>
          <code class="code">a0 = 0x67452301
b0 = 0xEFCDAB89
c0 = 0x98BADCFE
d0 = 0x10325476</code>
          <p>Für den weiteren Prozess basiert auf die vier folgenden Funktionen:</p>
          <code class="code python">F(X, Y, Z) = (X & Y) | (~X & Z)
G(X, Y, Z) = (X & Z) | (Y & ~Z)
H(X, Y, Z) = X ^ Y ^ Z
I(X, Y, Z) = Y ^ (X | ~Z)</code>
        </div>
        <div id="exampleCode">
          <h2>Beispielcode</h2>
          <p>Diese Beispielcodes zeigen mögliche Implementierungen des MD5-Algorithmus.</p>
          <p>Dies ist ein in Python geschriebener Beispielcode:</p>
          <code class="code python">import math

def md5(message):
    constants = [math.floor(abs(math.sin(i + 1)) * 2 ** 32) for i in range(64)]
    bytesArr = [ord(i) for i in message]
    bytesArr.append(1 << 7)
    while len(bytesArr) * 8 % 512 != 448:
        bytesArr.append(0)
    msgLen = len(message) * 8
    for i in range(8):
        bytesArr.append(msgLen & 0xFF)
        msgLen >>= 8
    words = []
    for i in range(len(bytesArr) - 1, 0, -4):
        word = 0
        for j in range(4):
            word <<= 8
            word |= bytesArr[i - j]
        words = [word] + words
    a0 = 0x67452301
    b0 = 0xEFCDAB89
    c0 = 0x98BADCFE
    d0 = 0x10325476
    a = 0; b = 0; c = 0; d = 0
    for startingIndex in range(0, len(words), 16):
        a = a0; b = b0; c = c0; d = d0
        for i in range(64):
            if i < 16:
                if i % 4 == 0: a = iterate(a, b, c, d, F, words[startingIndex + i], 7, constants[i])
                elif i % 4 == 1: d = iterate(d, a, b, c, F, words[startingIndex + i], 12, constants[i])
                elif i % 4 == 2: c = iterate(c, d, a, b, F, words[startingIndex + i], 17, constants[i])
                else: b = iterate(b, c, d, a, F, words[startingIndex + i], 22, constants[i])
            elif i < 32:
                if i % 4 == 0: a = iterate(a, b, c, d, G, words[startingIndex + (5 * i + 1) % 16], 5, constants[i])
                elif i % 4 == 1: d = iterate(d, a, b, c, G, words[startingIndex + (5 * i + 1) % 16], 9, constants[i])
                elif i % 4 == 2: c = iterate(c, d, a, b, G, words[startingIndex + (5 * i + 1) % 16], 14, constants[i])
                else: b = iterate(b, c, d, a, G, words[startingIndex + (5 * i + 1) % 16], 20, constants[i])
            elif i < 48:
                if i % 4 == 0: a = iterate(a, b, c, d, H, words[startingIndex + (3 * i + 5) % 16], 4, constants[i])
                elif i % 4 == 1: d = iterate(d, a, b, c, H, words[startingIndex + (3 * i + 5) % 16], 11, constants[i])
                elif i % 4 == 2: c = iterate(c, d, a, b, H, words[startingIndex + (3 * i + 5) % 16], 16, constants[i])
                else: b = iterate(b, c, d, a, H, words[startingIndex + (3 * i + 5) % 16], 23, constants[i])
            else:
                if i % 4 == 0: a = iterate(a, b, c, d, I, words[startingIndex + (7 * i) % 16], 6, constants[i])
                elif i % 4 == 1: d = iterate(d, a, b, c, I, words[startingIndex + (7 * i) % 16], 10, constants[i])
                elif i % 4 == 2: c = iterate(c, d, a, b, I, words[startingIndex + (7 * i) % 16], 15, constants[i])
                else: b = iterate(b, c, d, a, I, words[startingIndex + (7 * i) % 16], 21, constants[i])
        a0 += a; b0 += b; c0 += c; d0 += d
    return toLittleEndianStr(a0 % 2 ** 32) + toLittleEndianStr(b0 % 2 ** 32) + toLittleEndianStr(c0 % 2 ** 32) + toLittleEndianStr(d0 % 2 ** 32)

def toLittleEndianStr(num):
    arr = []
    for i in range(4):
        part = hex(num >> i * 8 & 0xFF)[2:]
        part = '0' * (2 - len(part)) + part
        arr.append(part)
    return "".join(i for i in arr)

def leftRotate(num, shift):
    num &= 0xFFFFFFFF
    return ((num << shift) | (num >> (32 - shift))) & 0xFFFFFFFF

iterate = lambda a, b, c, d, func, word, shift, constant: (b + leftRotate(a + func(b, c, d) + word + constant, shift)) % 2 ** 32
F = lambda X, Y, Z: X & Y | ~X & Z
G = lambda X, Y, Z: X & Z | Y & ~Z
H = lambda X, Y, Z: X ^ Y ^ Z
I = lambda X, Y, Z: Y ^ (X | ~Z)
</code>
          <p>Dies ist ein in Java geschriebener Beispielcode:</p>
          <code class="code java">import java.lang.Math;
.
.
.
public static String md5(String message) {
  int[] constants = new int[64];
  for (int i = 1; i <= 64; i++) constants[i - 1] = (int)Math.round(Math.floor(Math.abs(Math.sin(i) * Math.pow(2, 32))));
  int[] bytes = new int[(message.length() / 57 + 1) * 64];
  for (int i = 0; i < message.length(); i++) bytes[i] = (int)message.charAt(i);
  bytes[message.length()] = 1 << 7;
  for (int i = message.length() + 1; i < bytes.length - 8; i++) bytes[i] = 0;
  int msgLen = message.length() * 8;
  for (int i = 0; i < 8; i++) {
    bytes[bytes.length - 8 + i] = msgLen & 0xFF;
    msgLen >>= 8;
  }
  int[] words = new int[(message.length() / 57 + 1) * 16];
  for (int i = bytes.length - 1; i > 0; i-= 4) {
    int word = 0;
    for (int j = 0; j < 4; j++) {
      word <<= 8;
      word |= bytes[i - j];
    }
    words[i / 4] = word;
  }
  int a0 = 0x67452301;
  int b0 = 0xEFCDAB89;
  int c0 = 0x98BADCFE;
  int d0 = 0x10325476;

  int a, b, c, d;
  for (int startingIndex = 0; startingIndex < words.length; startingIndex += 16) {
    a = a0; b = b0; c = c0; d = d0;
    for (int i = 0; i < 64; i++) {
      if (i < 16) {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + F(b, c, d) + words[startingIndex + i] + constants[i], 7)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + F(a, b, c) + words[startingIndex + i] + constants[i], 12)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + F(d, a, b) + words[startingIndex + i] + constants[i], 17)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + F(c, d, a) + words[startingIndex + i] + constants[i], 22)) % (int)Math.pow(2, 32); break;
        }
      } else if (i < 32) {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + G(b, c, d) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 5)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + G(a, b, c) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 9)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + G(d, a, b) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 14)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + G(c, d, a) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 20)) % (int)Math.pow(2, 32); break;
        }
      } else if (i < 48) {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + H(b, c, d) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 4)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + H(a, b, c) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 11)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + H(d, a, b) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 16)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + H(c, d, a) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 23)) % (int)Math.pow(2, 32); break;
        }
      } else {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + I(b, c, d) + words[startingIndex + (7 * i) % 16] + constants[i], 6)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + I(a, b, c) + words[startingIndex + (7 * i) % 16] + constants[i], 10)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + I(d, a, b) + words[startingIndex + (7 * i) % 16] + constants[i], 15)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + I(c, d, a) + words[startingIndex + (7 * i) % 16] + constants[i], 21)) % (int)Math.pow(2, 32); break;
        }
      }
    }
    a0 += a; b0 += b; c0 += c; d0 += d;
  }
  return toLittleEndianStr(a0 % (int)Math.pow(2, 32)) + toLittleEndianStr(b0 % (int)Math.pow(2, 32)) + toLittleEndianStr(c0 % (int)Math.pow(2, 32)) + toLittleEndianStr(d0 % (int)Math.pow(2, 32));
}

public static String toLittleEndianStr(int num) {
  String[] arr = new String[4];
  for (int i = 0; i < 4; i++) {
    String part = Integer.toHexString(num >>> i * 8 & 0xFF);
    part = "0".repeat(2 - part.length()) + part;
    arr[i] = part;
  }
  String littleEndianStr = "";
  for (String str : arr) {
    littleEndianStr += str;
  }
  return littleEndianStr;
}

public static int leftRotate(int num, int shift) {
  return (num << shift) | (num >>> (32 - shift));
}

public static int F(int X, int Y, int Z) {
  return X & Y | ~X & Z;
}

public static int G(int X, int Y, int Z) {
  return X & Z | Y & ~Z;
}

public static int H(int X, int Y, int Z) {
  return X ^ Y ^ Z;
}

public static int I(int X, int Y, int Z) {
  return Y ^ (X | ~Z);
}
</code>
        </div>
        <div id="hasher">
          <h2>Text-Hasher</h2>
          <input type="text" name="message" placeholder="Gib hier deine Nachricht ein..." oninput="hash(this.value);">
          <p>Deine mit dem MD5-Algorithmus gehashte Nachricht:</p>
          <p id="hash"></p>
        </div>
      </div>
    </main>
  </body>
</html>
