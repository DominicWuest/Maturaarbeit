<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Message-Digest Algorithmus</title>
    <link rel="shortcut icon" type="image/x-icon" href="/imgs/favicon.ico"/>
    <link rel="stylesheet" href=<%= "/styles/" + path + ".css" %>>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P|Righteous" rel="stylesheet">
    <script src=<%= "/js/" + path + ".js" %> type="text/javascript"></script>
    <script src="/js/codeHighlighting.js" type="text/javascript"></script>
    <script type="text/javascript">
      const codeHighlighting = <%- JSON.stringify(codeHighlighting) %>;
    </script>
  </head>
  <body onload="hash(''); addHighlighting();">
    <%- include ../../partials/header.ejs %>
    <main>
      <div class="title">
        <h1>Message Digest Hash-Algorithmus</h1>
      </div>
      <div class="pageShortcuts">
        <h2>Page Shortcuts</h2>
        <ul>
          <li><a href="#history">Geschichte</a></li>
          <li><a href="#usage">Gebrauch</a></li>
          <li><a href="#specs">Spezifikationen</a></li>
          <li><a href="#functionality">Funktionsweise</a></li>
          <li><a href="#exampleCode">Beispielcode</a><ul>
            <li><a href="#java">Java</a></li>
          </ul></li>
          <li><a href="#hasher">Text-Hasher</a></li>
        </ul>
      </div>
      <div class="text">
        <div id="history">
          <h2>Geschichte</h2>
        </div>
        <div id="usage">
          <h2>Gebrauch</h2>
          <p>Aufgrund der <a href="#specs">kritischen Schwachstellen</a> des Algorithmus sollte er nie zur Verschlüsselung von Daten verwendet werden.</p>
          <p>Heutzutage wird der MD-Algorithmus hauptsächlich zur Kreierung von digital Fingerprints benutzt. Diese sind nützlich, um zu überprüfen, ob keine Daten bei Übertragungen verloren gegangen sind, da eine Datei vor und nach der Transmission den gleichen Hash mit sich bringt, falls kein Datenverlust stattgefunden hat.</p>
        </div>
        <div id="specs">
          <h2>Spezifikationen</h2>
          <p>Der MD-Algorithmus produziert einen 128-Bit Hash.</p>
          <p>Somit kann er 2<sup>128</sup> (Circa 3.4 ∗ 10<sup>38</sup>) einzigartige Hashes hervorbringen.</p>
          <p>Trotzdessen wird er heute als unsicher klassifiziert. Manchmal genügt lediglich eine schnelle <a href="https://www.google.com/search?q=276f8db0b86edaa7fc805516c852c889&rlz=1C1CHBF_deCH819CH819&oq=276f8db0b86edaa7fc805516c852c889&aqs=chrome..69i57.411j0j7&sourceid=chrome&ie=UTF-8" target="_blank">Google Suche</a> eines Hashes, um dessen Ursprung herauszufinden.</p>
          <p>Aufgrund der schnellen Generierung eines MD-Hashes ist es relativ einfach, eine Kollision zu bruteforcen.</p>
          <p>Eine Kollision eines MD5-Hashes kann durch Anwendung von verschiedenen Tricks in 15-60 Minuten gefunden werden, wobei dies bei einem MD4-Hash weniger als eine Sekunde dauert.</p>
        </div>
        <div id="functionality">
          <h2>Funktionsweise</h2>
        </div>
        <div id="exampleCode">
          <h2>Beispielcode</h2>
          <p>Diese Beispielcodes zeigen mögliche Implementierungen des MD5-Algorithmus.</p>
          <code class="code java">import java.lang.Math;
.
.
.
public static String md5(String message) {
  int[] constants = new int[64];
  for (int i = 1; i <= 64; i++) constants[i - 1] = (int)Math.round(Math.floor(Math.abs(Math.sin(i) * Math.pow(2, 32))));
  int[] bytes = new int[(message.length() / 57 + 1) * 64];
  for (int i = 0; i < message.length(); i++) bytes[i] = (int)message.charAt(i);
  bytes[message.length()] = 1 << 7;
  for (int i = message.length() + 1; i < bytes.length - 8; i++) bytes[i] = 0;
  int msgLen = message.length() * 8;
  for (int i = 0; i < 8; i++) {
    bytes[bytes.length - 8 + i] = msgLen & 0xFF;
    msgLen >>= 8;
  }
  int[] words = new int[(message.length() / 57 + 1) * 16];
  for (int i = bytes.length - 1; i > 0; i-= 4) {
    int word = 0;
    for (int j = 0; j < 4; j++) {
      word <<= 8;
      word |= bytes[i - j];
    }
    words[i / 4] = word;
  }
  int a0 = 0x67452301;
  int b0 = 0xEFCDAB89;
  int c0 = 0x98BADCFE;
  int d0 = 0x10325476;

  int a, b, c, d;
  for (int startingIndex = 0; startingIndex < words.length; startingIndex += 16) {
    a = a0; b = b0; c = c0; d = d0;
    for (int i = 0; i < 64; i++) {
      if (i < 16) {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + F(b, c, d) + words[startingIndex + i] + constants[i], 7)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + F(a, b, c) + words[startingIndex + i] + constants[i], 12)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + F(d, a, b) + words[startingIndex + i] + constants[i], 17)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + F(c, d, a) + words[startingIndex + i] + constants[i], 22)) % (int)Math.pow(2, 32); break;
        }
      } else if (i < 32) {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + G(b, c, d) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 5)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + G(a, b, c) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 9)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + G(d, a, b) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 14)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + G(c, d, a) + words[startingIndex + (5 * i + 1) % 16] + constants[i], 20)) % (int)Math.pow(2, 32); break;
        }
      } else if (i < 48) {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + H(b, c, d) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 4)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + H(a, b, c) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 11)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + H(d, a, b) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 16)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + H(c, d, a) + words[startingIndex + (3 * i + 5) % 16] + constants[i], 23)) % (int)Math.pow(2, 32); break;
        }
      } else {
        switch (i % 4) {
          case 0: a = (b + leftRotate(a + I(b, c, d) + words[startingIndex + (7 * i) % 16] + constants[i], 6)) % (int)Math.pow(2, 32); break;
          case 1: d = (a + leftRotate(d + I(a, b, c) + words[startingIndex + (7 * i) % 16] + constants[i], 10)) % (int)Math.pow(2, 32); break;
          case 2: c = (d + leftRotate(c + I(d, a, b) + words[startingIndex + (7 * i) % 16] + constants[i], 15)) % (int)Math.pow(2, 32); break;
          case 3: b = (c + leftRotate(b + I(c, d, a) + words[startingIndex + (7 * i) % 16] + constants[i], 21)) % (int)Math.pow(2, 32); break;
        }
      }
    }
    a0 += a; b0 += b; c0 += c; d0 += d;
  }
  return toLittleEndianStr(a0 % (int)Math.pow(2, 32)) + toLittleEndianStr(b0 % (int)Math.pow(2, 32)) + toLittleEndianStr(c0 % (int)Math.pow(2, 32)) + toLittleEndianStr(d0 % (int)Math.pow(2, 32));
}

public static String toLittleEndianStr(int num) {
  String[] arr = new String[4];
  for (int i = 0; i < 4; i++) {
    String part = Integer.toHexString(num >>> i * 8 & 0xFF);
    part = "0".repeat(2 - part.length()) + part;
    arr[i] = part;
  }
  String littleEndianStr = "";
  for (String str : arr) {
    littleEndianStr += str;
  }
  return littleEndianStr;
}

public static int leftRotate(int num, int shift) {
  return (num << shift) | (num >>> (32 - shift));
}

public static int F(int X, int Y, int Z) {
  return X & Y | ~X & Z;
}

public static int G(int X, int Y, int Z) {
  return X & Z | Y & ~Z;
}

public static int H(int X, int Y, int Z) {
  return X ^ Y ^ Z;
}

public static int I(int X, int Y, int Z) {
  return Y ^ (X | ~Z);
}
</code>
        </div>
        <div id="hasher">
          <h2>Text-Hasher</h2>
          <input type="text" name="message" placeholder="Gib hier deine Nachricht ein..." oninput="hash(this.value);">
          <p>Deine mit dem MD5-Algorithmus gehashte Nachricht:</p>
          <p id="hash"></p>
        </div>
      </div>
    </main>
  </body>
</html>
