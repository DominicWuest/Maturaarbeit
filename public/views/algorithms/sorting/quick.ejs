<!DOCTYPE html>
<!-- Daniel Isler -->
<html lang = "de">
  <head>
    <meta charset="utf-8">
    <title>Quicksort</title>
    <link rel="shortcut icon" type="image/x-icon" href="/imgs/favicon.ico"/>
    <link rel="stylesheet" href=<%= "/styles/" + path + ".css" %>>
    <link href="https://fonts.googleapis.com/css?family=Press+Start+2P|Righteous" rel="stylesheet">
    <script src=<%= "/js/" + path + ".js" %> type="text/javascript"></script>
    <script src="/js/codeHighlighting.js" type="text/javascript"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/0.5.6/p5.js"></script>
    <script type="text/javascript">
      const codeHighlighting = <%- JSON.stringify(codeHighlighting) %>;
    </script>
  </head>
  <body onload="addHighlighting(); restartAnimation(); noLoop(); needsScrambling = false;" onresize="setup();">
    <%- include ../../partials/header.ejs %>
    <main>
      <div class="title">
        <h1>Quicksort</h1>
      </div>
      <div class="pageShortcuts">
        <h2>Page Shortcuts</h2>
        <ul>
          <li><a href="#usage">Gebrauch</a></li>
          <li><a href="#specs">Spezifikationen</a></li>
          <li><a href="#functionality">Funktionsweise</a></li>
          <li><a href="#exampleCode">Beispielcode</a><ul>
            <li><a href="#python">Python</a></li>
            <li><a href="#java">Java</a></li>
          </ul></li>
          <li><a href="#animatedExample">Animiertes Beispiel</a></li>
        </ul>
      </div>
      <div class="text">
        <div id="usage">
          <h2>Gebrauch</h2>
          <p>Der Quicksort wird gebraucht, um einen Array zu sortieren.</p>
          <p>Der Quicksort kann sehr effizient sein, er kann jedoch im schlechtesten Fall genauso ineffizient wie die einfacheren Sortieralgorithmen sein.</p>
        </div>
        <div id="specs">
          <h2>Spezifikationen</h2>
          <p>Beim Quicksort werden im schlechtesten Fall, der aber nur sehr selten vorkommt <span class="bigO">O(n<sup>2</sup>) Vergleichen</span> durcheführt. Die best-case Performance besteht aus <span class="bigO">O(n * log(n)) Vergleichen</span>. Seine Durchschnittsperformance beträgt <span class="bigO">O(n * log(n)) Vergleiche.</p>
          <p>Da der Algorithmus im schlechtesten Fall n weitere Arrays benötigt hat er eine Space-complexity von <span class="bigO">O(n)</span>.</p>
        </div>
        <div id="functionality">
          <h2>Funktionsweise</h2>
          <p>Der Quicksort Algorithmus arbeitet nach dem Teile-und-herrsche-Verfahren.</p>
          <p>Das Grundprinzip vom Teile-und-herrsche-Verfahren ist, dass ein Problem, welches sehr schwierig erscheint so lange in einfachere Teilprobleme zerlegt wird, bis diese beherrschbar, also gelöst sind. Dieses Verfahren kann von einer rekursiven Funktion, also einer Funktion, die sich selber aufruft, durchgeführt werden. Die Lösung des letzten Teilproblems ist dabei auch die Lösung des Gesamtproblems.</p>
          <p>Beim Quicksort wird </p>
        </div>
        <div id="exampleCode">
          <h2>Beispielcode</h2>
          <p class="codeDescription">Dies ist ein in Python geschriebener Beispielcode:</p>
          <code class="code python">def bubbleSort(arr): # arr ist der Array, welcher zu sortieren ist. Die Funktion gibt den sortierten Array zurück
  max = len(arr) - 1 # Der maximale Index, welcher der fokussierte Wert haben kann
  focusedIndex = 0 # Der fokussierte Index
  comparedIndex = 1 # Der Index des Wertes, welcher mit dem Wert am fokussierten Index verglichen wird
  while max > 1: # Sobald der maximal zu fokussierende Index 1 ist, ist der Array sortiert. Falls max anfangs schon kleiner als 1 ist, hat der Array so wenig Elemente, dass er schon sortiert ist
    if focusedIndex == max: # Falls der fokussierte Index dem maximal zu fokussierendem Index entspricht, wird der Algorithmus wieder vom Index null weitergeführt
      max -= 1 # Der maximal zu fokussierende Index muss nun um eins kleiner sein
      focusedIndex = 0 # Man beginnt wieder am Anfang des Arrays => Der fokussierte Index ist wieder 0
      comparedIndex = 1 # Der Index, mit dem verglichen wird, ist wieder 1
    if arr[focusedIndex] > arr[comparedIndex]: # Falls der Wert am fokussierten Index grösser ist als der am Verglichenen
      arr[focusedIndex], arr[comparedIndex] = arr[comparedIndex], arr[focusedIndex] # Die beiden Werte werden miteinander getauscht
    focusedIndex += 1 # Nach jeder Iteration wird der fokussierte Index um eins erhöht
    comparedIndex += 1 # Nach jeder Iteration wird der verglichene Index um eins erhöht
  return arr # Der sortierte Array wird zurückgegeben</code>
          <p class="codeDescription">Dies ist ein in Java geschriebener Beispielcode:</p>
          <p>Es können selbstverständlich auch andere Datentypen gebraucht werden. </p>
          <code class="code java">public static int bubbleSort(int[] arr) { // arr ist der Array, welcher zu sortieren ist. Die Funktion gibt den sortierten Array zurück
  int max = arr.length - 1; // Der maximale Index, welcher der fokussierte Wert haben kann
  int focusedIndex = 0; // Der fokussierte Index
  int comparedIndex = 1; // Der Index des Wertes, welcher mit dem Wert am fokussierten Index verglichen wird
  while (max > 1) { // Sobald der maximal zu fokussierene Index 1 ist, ist der Array sortiert. Falls max anfangs schon kleiner als 1 ist, hat der Array so wenig Elemente, dass er schon sortiert ist
    if (focusedIndex == max) { // Falls der fokussierte Index dem maximal zu fokussireendem Index entspricht, wird der Algorithmus wieder vom Index null weitergeführt
      max--; // Der maximal zu fokussierende Index muss nun um eins kleiner sein
      focusedIndex = 0; // Man beginnt wieder am Anfang des Arrays => Der fokussierte Index ist wieder 0
      comparedIndex = 1; // Der Index, mit dem verglichen wird, ist wieder 1
    }
    if (arr[focusedIndex] > arr[comparedIndex]) { // Falls der Wert am fokussierten Index grösser ist als der am Verglichenen, werden die beiden Werte miteinander getauscht
      int temp = arr[focusedIndex];
      arr[focusedIndex] = arr[comparedIndex];
      arr[comparedIndex] = temp;
    }
    focusedIndex++; // Nach jeder Iteration wird der fokussierte Index um eins erhöht
    comparedIndex++; // Nach jeder Iteration wird der verglichene Index um eins erhöht
  }
  return arr; // Der sortierte Array wird zurückgegeben
}</code>
        </div>
        <div id="animatedExample">
          <h2>Animiertes Beispiel</h2>
          <div class="legend">
            <h3>Legende</h3>
            <ul>
              <li><span style="color: blue;">Fokussierter Wert</span></li>
              <li><span style="color: purple">Wert, mit dem der fokussierte Wert verglichen wird</span></li>
              <li><span style="color: green;">Momentan nicht beachteter Wert</span></li>
              <li><span style="color: gray;">Wert am korrekten Index</span></li>
            </ul>
          </div>
          <p>Drücke Start, um die Animation zu starten. Ändere die Position des Sliders, um die Geschwindigkeit der Animation zu verändern.</p>
          <div class="animationInput">
              <input type="button" name="restartAnimation" value="Start" onmouseup="restartAnimation(); needsScrambling = true;" ontouchend="restartAnimation(); needsScrambling = true;">
              <input type="range" name="fps" min="0" max="5" step="0.0001" oninput="fps = Math.pow(2, this.value);">
          </div>
          <div id="animation"></div>
        </div>
      </div>
    </main>
  </body>
</html>
